import path from 'path';
import fs from 'fs';
import glob from 'glob';

import { loadModule } from '@use-gpu/shader/glsl';

const PACKAGE_JSON = './package.json';
const INDEX_TS = './src/index.ts';
const TYPEDEF_TS = './types/glsl-files/index.d.ts';
const TARGET = '../../build/packages/glsl';

const files = glob.sync('./**/*.glsl');

const escape = (s: string) => JSON.stringify(s.toString());
const serialize = (s: any) => JSON.stringify(s, null, 2);

const keys: string[] = [];
const names: string[] = [];
const paths: string[] = [];
const modules: any[] = [];

const copyToTarget = (file: string) => {
  const target = path.join(TARGET, file);
  const dir = path.dirname(target);
  fs.mkdirSync(dir, {recursive: true});
  fs.copyFileSync(file, target);
}

for (const file of files) {
  const keys = file.split('/');

  const id = keys.pop()!.replace(/\.glsl$/, '');
  const tokens = [...keys.slice(1), id];
  const name = tokens.join('/');

  copyToTarget(file);

  const code = fs.readFileSync(file).toString();
  const module = loadModule(code, file);

  paths.push(file);
  names.push(name.replace('src/', ''));
  modules.push(module);
}

// Update exports in package.json
try {
  const PKG = JSON.parse(fs.readFileSync(PACKAGE_JSON).toString());
  PKG.exports = {".": "./src/index.ts"};
  for (let path of paths) {
    PKG.exports[path.replace('src/', '')] = {
      "types": path.replace(/.glsl$/, '.d.ts'),
      "import": path,
      "require": path,
    };
  }
  const json = JSON.stringify(PKG, null, 2);
  fs.writeFileSync(PACKAGE_JSON, json);
} catch (e) {}

// Generate static include for testing
const staticMap = {} as Record<string, string>;
files.forEach((file, i) => {
  const code = fs.readFileSync(file).toString();
  staticMap[names[i]] = code;
  staticMap['@use-gpu/glsl/' + names[i]] = code;
});
const ts = `// File generated by build.ts. Do not edit directly.
// This file provides all the shader code in a statically importable form, used for testing.
export const GLSLModules = ${serialize(staticMap)};
export default GLSLModules;
`;
fs.writeFileSync(INDEX_TS, ts);

// Generate type definition
const makeTSModule = (file: string, symbols?: string[]) => {
  const pattern = file.replace('./src/', '@use-gpu/glsl/');
  return `declare module ${escape(pattern)} {
  type ParsedBundle = import('@use-gpu/shader/glsl/types').ParsedBundle;
  const __module: ParsedBundle;
  ${(symbols ?? []).map(s => `export const ${s}: ParsedBundle;`).join("\n  ")}
  export default __module;
}
`
};

files.map((file, i) => {
  const typeDef = makeTSModule(file, modules[i].table.visibles);
  const dts = file.replace(/\.glsl$/, '.d.ts');
  fs.writeFileSync(dts, typeDef);
});

const typeDef = [
  `// File generated by build.ts. Do not edit directly.
declare module '@use-gpu/glsl' {
  export const GLSLModules: Record<string, string>;
  export default GLSLModules;
}
  `,
  ...files.map((file, i) => makeTSModule(file, modules[i].table.visibles)),
].join("\n");

fs.writeFileSync(TYPEDEF_TS, typeDef);
copyToTarget(TYPEDEF_TS);
