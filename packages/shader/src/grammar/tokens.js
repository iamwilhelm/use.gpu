import { ExternalTokenizer } from '@lezer/lr';
import { UntilEOL, UntilCommentClose, Directive, BasicType, Keyword, Reserved } from './glsl.terms';

export const untilEOL = new ExternalTokenizer(
  (input, stack) => {
    while (true) {
      const v = input.next;
      // \ + \n
      if (v === 92 && input.peek(1) === 10) input.advance();
      // \n | EOF
      else if (v === 10 || v === -1) return input.acceptToken(UntilEOL);
      input.advance();
    }
  },
);

export const untilCommentClose = new ExternalTokenizer(
  (input, stack) => {
    while (true) {
      // */
      const v = input.next;
      if (v === 42 && input.peek(1) === 47) {
        return input.acceptToken(UntilCommentClose, 1);
      }
      input.advance();
    }
  },
);

export const specializeDirective = (text) => DIRECTIVES.has(text) ? Directive : -1;
export const specializeType      = (text) => TYPES.has(text) ? BasicType : -1;
export const specializeKeyword   = (text) => KEYWORDS.has(text) ? Keyword : -1;
export const specializeReserved  = (text) => RESERVED.has(text) ? Reserved : -1;

const DIRECTIVES = new Set([
	"define",
  "undef",
  "if",
  "ifdef",
  "ifndef",
  "else",
  "elif",
  "endif",
  "error",
  "pragma",
  "extension",
  "version",
  "line"
]);

const TYPES = new Set([
  "void",
	"float",
	"double",
	"int",
	"uint",
  "atomic_uint",
	"bool",
	"mat2",
	"mat3",
	"mat4",
	"dmat2",
	"dmat3",
	"dmat4",
	"mat2x2",
	"mat2x3",
	"mat2x4",
	"dmat2x2",
	"dmat2x3",
	"dmat2x4",
	"mat3x2",
	"mat3x3",
	"mat3x4",
	"dmat3x2",
	"dmat3x3",
	"dmat3x4",
	"mat4x2",
	"mat4x3",
	"mat4x4",
	"dmat4x2",
	"dmat4x3",
	"dmat4x4",
	"vec2",
	"vec3",
	"vec4",
	"ivec2",
	"ivec3",
	"ivec4",
	"bvec2",
	"bvec3",
	"bvec4",
	"dvec2",
	"dvec3",
	"dvec4",
	"uvec2",
	"uvec3",
	"uvec4",
  "sampler3D",
  "samplerCube",
  "sampler1DShadow",
  "sampler2DShadow",
  "samplerCubeShadow",
  "sampler1DArray",
  "sampler2DArray",
  "sampler1DArrayShadow",
  "sampler2DArrayShadow",
  "samplerCubeArray",
  "samplerCubeArrayShadow",
  "isampler1D",
  "isampler2D",
  "isampler3D",
  "isamplerCube",
  "isampler1DArray",
  "isampler2DArray",
  "isamplerCubeArray",
  "usampler1D",
  "usampler2D",
  "usampler3D",
  "usamplerCube",
  "usampler1DArray",
  "usampler2DArray",
  "usamplerCubeArray",
  "sampler2DRect",
  "sampler2DRectShadow",
  "isampler2DRect",
  "usampler2DRect",
  "samplerBuffer",
  "isamplerBuffer",
  "usamplerBuffer",
  "sampler2DMS",
  "isampler2DMS",
  "usampler2DMS",
  "sampler2DMSArray",
  "isampler2DMSArray",
  "usampler2DMSArray",
  "image1D",
  "iimage1D",
  "uimage1D",
  "image2D",
  "iimage2D",
  "uimage2D",
  "image3D",
  "iimage3D",
  "uimage3D",
  "image2DRect",
  "iimage2DRect",
  "uimage2DRect",
  "imageCube",
  "iimageCube",
  "uimageCube",
  "imageBuffer",
  "iimageBuffer",
  "uimageBuffer",
  "image1DArray",
  "iimage1DArray",
  "uimage1DArray",
  "image2DArray",
  "iimage2DArray",
  "uimage2DArray",
  "imageCubeArray",
  "iimageCubeArray",
  "uimageCubeArray",
  "image2DMS",
  "iimage2DMS",
  "uimage2DMS",
  "image2DMSArray",
  "iimage2DMSArray",
  "uimage2DMSArray",
]);

const KEYWORDS = new Set([
	"attribute",
	"const",
	"uniform",
	"varying",
	"buffer",
	"shared",
	"coherent",
	"volatile",
	"restrict",
	"readonly",
	"writeonly",
	"layout",
	"centroid",
	"flat",
	"smooth",
	"noperspective",
	"patch",
	"sample",
	"break",
	"continue",
	"do",
	"for",
	"while",
	"switch",
	"case",
	"default",
	"if",
	"else",
	"subroutine",
	"in",
	"out",
	"inout",
	"true",
	"false",
	"invariant",
	"precise",
	"discard",
	"return",
]);

const RESERVED = new Set([
	"common",
	"partition",
	"active",
	"asm",
	"class",
	"union",
	"enum",
	"typedef",
	"template",
	"this",
	"resource",
	"goto",
	"inline",
	"noinline",
	"public",
	"static",
	"extern",
	"external",
	"interface",
	"long",
	"short",
	"half",
	"fixed",
	"unsigned",
	"superp",
	"input",
	"output",
	"hvec2",
	"hvec3",
	"hvec4",
	"fvec2",
	"fvec3",
	"fvec4",
	"sampler3DRect",
	"filter",
	"sizeof",
	"cast",
	"namespace",
	"using",
]);
