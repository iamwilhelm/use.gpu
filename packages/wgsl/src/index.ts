// File generated by build.ts. Do not edit directly.
// This file provides all the shader code in a statically importable form, used for testing.
export const WGSLModules = {
  "instance/draw/mesh": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\nfn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\nfn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\nfn worldToClip(position: vec4<f32>) -> vec4<f32> {\n\treturn viewToClip(worldToView(position));\n}\n\nstruct VertexOutput {\n\t@builtin(position) position: vec4<f32>;\n\t@location(0) fragColor: vec4<f32>;\n\t@location(1) fragUV: vec2<f32>;\n\t@location(2) fragNormal: vec3<f32>;\n\t@location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32\n) -> VertexOutput {\n\t\n\tvec4<f32> outPosition = worldToClip(position);\n\t\n  return VertexOutput(\n\t\toutPosition,\n\t\tcolor,\n\t\tuv,\n\t\tnormal.xyz,\n\t\tposition.xyz,\n\t);\n}\n\n/*\n#pragma import {worldToClip} from '@use-gpu/glsl/use/view'\n#pragma import {pickingUniforms} from '@use-gpu/glsl/use/picking';\n#pragma import {lightUniforms} from '@use-gpu/glsl/use/light';\n\nlayout(location = 0) in vec4 position;\nlayout(location = 1) in vec4 normal;\nlayout(location = 2) in vec4 color;\nlayout(location = 3) in vec2 uv;\n\n#ifdef IS_PICKING\nlayout(location = 0) out flat uint fragIndex;\n#else\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec2 fragUV;\n\nlayout(location = 2) out vec3 fragNormal;\nlayout(location = 3) out vec3 fragPosition;\n#endif\n\nvoid main() {\n  int instanceIndex = gl_InstanceIndex;\n  gl_Position = worldToClip(position);\n#ifdef IS_PICKING\n  fragIndex = uint(instanceIndex);\n#else\n  fragColor = color;\n  fragUV = uv;\n\n  fragNormal = normal.xyz;\n  fragPosition = position.xyz;\n#endif\n}\n*/",
  "@use-gpu/wgsl/instance/draw/mesh": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\nfn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\nfn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\nfn worldToClip(position: vec4<f32>) -> vec4<f32> {\n\treturn viewToClip(worldToView(position));\n}\n\nstruct VertexOutput {\n\t@builtin(position) position: vec4<f32>;\n\t@location(0) fragColor: vec4<f32>;\n\t@location(1) fragUV: vec2<f32>;\n\t@location(2) fragNormal: vec3<f32>;\n\t@location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32\n) -> VertexOutput {\n\t\n\tvec4<f32> outPosition = worldToClip(position);\n\t\n  return VertexOutput(\n\t\toutPosition,\n\t\tcolor,\n\t\tuv,\n\t\tnormal.xyz,\n\t\tposition.xyz,\n\t);\n}\n\n/*\n#pragma import {worldToClip} from '@use-gpu/glsl/use/view'\n#pragma import {pickingUniforms} from '@use-gpu/glsl/use/picking';\n#pragma import {lightUniforms} from '@use-gpu/glsl/use/light';\n\nlayout(location = 0) in vec4 position;\nlayout(location = 1) in vec4 normal;\nlayout(location = 2) in vec4 color;\nlayout(location = 3) in vec2 uv;\n\n#ifdef IS_PICKING\nlayout(location = 0) out flat uint fragIndex;\n#else\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec2 fragUV;\n\nlayout(location = 2) out vec3 fragNormal;\nlayout(location = 3) out vec3 fragPosition;\n#endif\n\nvoid main() {\n  int instanceIndex = gl_InstanceIndex;\n  gl_Position = worldToClip(position);\n#ifdef IS_PICKING\n  fragIndex = uint(instanceIndex);\n#else\n  fragColor = color;\n  fragUV = uv;\n\n  fragNormal = normal.xyz;\n  fragPosition = position.xyz;\n#endif\n}\n*/",
  "instance/fragment/mesh": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\nstruct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n@group(0) @binding(1) var<uniform> lightUniforms: LightUniforms;\n\n@group(1) @binding(0) var<uniform> s: sampler;\n@group(1) @binding(1) var<uniform> t: texture2D;\n\nstruct FragmentOutput {\n\t@location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n\t@location(0) fragColor: vec4<f32>,\n\t@location(1) fragUV: vec2<f32>,\n\t@location(2) fragNormal: vec3<f32>,\n\t@location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = texture(sampler2D(t, s), fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) discard;\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n\treturn FragmentOutput(outColor);\n}\n\n/*\n#pragma import {PBR} from '@use-gpu/glsl/fragment/pbr';\n#pragma import {getPickingColor} from '@use-gpu/glsl/use/picking';\n#pragma import {viewUniforms} from '@use-gpu/glsl/use/view';\n#pragma import {lightUniforms} from '@use-gpu/glsl/use/light';\n\n#ifdef IS_PICKING\nlayout(location = 0) in flat uint fragIndex;\nlayout(location = 0) out uvec4 outColor;\n#else\nlayout(set = 1, binding = 0) uniform sampler s;\nlayout(set = 1, binding = 1) uniform texture2D t;\n\nlayout(location = 0) in vec4 fragColor;\nlayout(location = 1) in vec2 fragUV;\n\nlayout(location = 2) in vec3 fragNormal;\nlayout(location = 3) in vec3 fragPosition;\n\nlayout(location = 0) out vec4 outColor;\n#endif\n\n#ifdef IS_PICKING\nvoid main() {\n  outColor = getPickingColor(fragIndex);\n}\n#else\nvoid main() {\n  vec3 fragLight = lightUniforms.lightPosition.xyz - fragPosition;\n  vec3 fragView = viewUniforms.viewPosition.xyz - fragPosition;\n\n  vec3 N = normalize(fragNormal);\n  vec3 L = normalize(fragLight);\n  vec3 V = normalize(fragView);\n\n  vec4 texColor = texture(sampler2D(t, s), fragUV);\n  vec4 inColor = fragColor * texColor;\n  if (inColor.a <= 0.0) discard;\n\n  vec3 albedo = inColor.rgb;\n  float metalness = 0.2;\n  float roughness = 0.8;\n\n  vec3 color = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  outColor = vec4(color, inColor.a);\n\n}\n#endif\n\n*/",
  "@use-gpu/wgsl/instance/fragment/mesh": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\nstruct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n@group(0) @binding(1) var<uniform> lightUniforms: LightUniforms;\n\n@group(1) @binding(0) var<uniform> s: sampler;\n@group(1) @binding(1) var<uniform> t: texture2D;\n\nstruct FragmentOutput {\n\t@location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n\t@location(0) fragColor: vec4<f32>,\n\t@location(1) fragUV: vec2<f32>,\n\t@location(2) fragNormal: vec3<f32>,\n\t@location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = texture(sampler2D(t, s), fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) discard;\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n\treturn FragmentOutput(outColor);\n}\n\n/*\n#pragma import {PBR} from '@use-gpu/glsl/fragment/pbr';\n#pragma import {getPickingColor} from '@use-gpu/glsl/use/picking';\n#pragma import {viewUniforms} from '@use-gpu/glsl/use/view';\n#pragma import {lightUniforms} from '@use-gpu/glsl/use/light';\n\n#ifdef IS_PICKING\nlayout(location = 0) in flat uint fragIndex;\nlayout(location = 0) out uvec4 outColor;\n#else\nlayout(set = 1, binding = 0) uniform sampler s;\nlayout(set = 1, binding = 1) uniform texture2D t;\n\nlayout(location = 0) in vec4 fragColor;\nlayout(location = 1) in vec2 fragUV;\n\nlayout(location = 2) in vec3 fragNormal;\nlayout(location = 3) in vec3 fragPosition;\n\nlayout(location = 0) out vec4 outColor;\n#endif\n\n#ifdef IS_PICKING\nvoid main() {\n  outColor = getPickingColor(fragIndex);\n}\n#else\nvoid main() {\n  vec3 fragLight = lightUniforms.lightPosition.xyz - fragPosition;\n  vec3 fragView = viewUniforms.viewPosition.xyz - fragPosition;\n\n  vec3 N = normalize(fragNormal);\n  vec3 L = normalize(fragLight);\n  vec3 V = normalize(fragView);\n\n  vec4 texColor = texture(sampler2D(t, s), fragUV);\n  vec4 inColor = fragColor * texColor;\n  if (inColor.a <= 0.0) discard;\n\n  vec3 albedo = inColor.rgb;\n  float metalness = 0.2;\n  float roughness = 0.8;\n\n  vec3 color = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  outColor = vec4(color, inColor.a);\n\n}\n#endif\n\n*/"
};
export default WGSLModules;
