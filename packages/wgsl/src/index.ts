// File generated by build.ts. Do not edit directly.
// This file provides all the shader code in a statically importable form, used for testing.
export const WGSLModules = {
  "fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = diffuseColor * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = max(vec3<f32>(0.0), Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "@use-gpu/wgsl/fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = diffuseColor * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = max(vec3<f32>(0.0), Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "fragment/sdf-2d": "@export struct SDF {\n  outer: f32,\n  inner: f32,\n};\n\n// Get SDF scale based on pixel UV coordinates.\n//\n// d(sdfUV) / d(fragX|fragY) = px / px\n@export fn getUVScale(sdfUV: vec2<f32>) -> f32 {\n  var dx = dpdx(sdfUV);\n  var dy = dpdy(sdfUV);\n  return (length(dx) + length(dy)) * 0.5;\n}\n\n@export fn getBoxSDF(box: vec2<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  // Get absolute pixels for this box quadrant\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * box;\n\n  // Box SDF (approx)\n  var d1 = max(xy.x, xy.y);\n  var outer = -d1;\n  var o = outer / scale;\n\n  return SDF(o, o);\n}\n\n@export fn getBorderBoxSDF(box: vec2<f32>, border: vec4<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  // Get absolute pixels for this box quadrant\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * box;\n\n  // Box outer SDF (approx)\n  var d1 = max(xy.x, xy.y);\n  var outer = -d1;\n  \n  // Box inner SDF (approx)\n  var flipUV = vec4<f32>(uv, 1.0 - uv);\n  var tl = flipUV.xy * box;\n  var tr = flipUV.zy * box;\n  var bl = flipUV.xw * box;\n  var br = flipUV.zw * box;\n\n  var i4 = vec4<f32>(\n    getBoxCorner(tl, vec2<f32>(border.x, border.y)),\n    getBoxCorner(tr, vec2<f32>(border.z, border.y)),\n    getBoxCorner(bl, vec2<f32>(border.x, border.w)),\n    getBoxCorner(br, vec2<f32>(border.z, border.w)),\n  );\n  var inner = min(min(i4.x, i4.y), min(i4.z, i4.w));\n\n  return SDF(outer / scale, inner / scale);\n}\n\n@export fn getRoundedBorderBoxSDF(box: vec2<f32>, border: vec4<f32>, radius: vec4<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  var flipUV = vec4<f32>(uv, 1.0 - uv);\n  var tl = flipUV.xy * box;\n  var tr = flipUV.zy * box;\n  var bl = flipUV.xw * box;\n  var br = flipUV.zw * box;\n\n  var o4 = vec4<f32>(\n    getCircleCorner(tl, radius.x),\n    getCircleCorner(tr, radius.y),\n    getCircleCorner(bl, radius.w),\n    getCircleCorner(br, radius.z),\n  );\n  var outer = min(min(o4.x, o4.y), min(o4.z, o4.w));\n\n  tl -= border.xy;\n  tr -= border.zy;\n  bl -= border.xw;\n  br -= border.zw;\n  \n  var innerRadius = max(\n    vec4<f32>(0.0),\n    radius - vec4<f32>(\n      max(border.x, border.y),\n      max(border.z, border.y),\n      max(border.x, border.w),\n      max(border.z, border.w),\n    )\n  );\n\n  var i4 = vec4<f32>(\n    getCircleCorner(tl, innerRadius.x),\n    getCircleCorner(tr, innerRadius.y),\n    getCircleCorner(bl, innerRadius.w),\n    getCircleCorner(br, innerRadius.z),\n  );\n  var inner = min(min(i4.x, i4.y), min(i4.z, i4.w));\n\n  return SDF(outer / scale, inner / scale);\n}\n\nfn getBoxCorner(xy: vec2<f32>, offset: vec2<f32>) -> f32 {\n  var clip = xy - offset;\n  return min(clip.x, clip.y);\n}\n\nfn getCircleCorner(xy: vec2<f32>, r: f32) -> f32 {\n  var clip = max(vec2<f32>(0.0), r - xy);\n  var neg = min(0.0, max(-xy.x, -xy.y) + r);\n  return r - length(clip) - neg;\n}\n",
  "@use-gpu/wgsl/fragment/sdf-2d": "@export struct SDF {\n  outer: f32,\n  inner: f32,\n};\n\n// Get SDF scale based on pixel UV coordinates.\n//\n// d(sdfUV) / d(fragX|fragY) = px / px\n@export fn getUVScale(sdfUV: vec2<f32>) -> f32 {\n  var dx = dpdx(sdfUV);\n  var dy = dpdy(sdfUV);\n  return (length(dx) + length(dy)) * 0.5;\n}\n\n@export fn getBoxSDF(box: vec2<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  // Get absolute pixels for this box quadrant\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * box;\n\n  // Box SDF (approx)\n  var d1 = max(xy.x, xy.y);\n  var outer = -d1;\n  var o = outer / scale;\n\n  return SDF(o, o);\n}\n\n@export fn getBorderBoxSDF(box: vec2<f32>, border: vec4<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  // Get absolute pixels for this box quadrant\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * box;\n\n  // Box outer SDF (approx)\n  var d1 = max(xy.x, xy.y);\n  var outer = -d1;\n  \n  // Box inner SDF (approx)\n  var flipUV = vec4<f32>(uv, 1.0 - uv);\n  var tl = flipUV.xy * box;\n  var tr = flipUV.zy * box;\n  var bl = flipUV.xw * box;\n  var br = flipUV.zw * box;\n\n  var i4 = vec4<f32>(\n    getBoxCorner(tl, vec2<f32>(border.x, border.y)),\n    getBoxCorner(tr, vec2<f32>(border.z, border.y)),\n    getBoxCorner(bl, vec2<f32>(border.x, border.w)),\n    getBoxCorner(br, vec2<f32>(border.z, border.w)),\n  );\n  var inner = min(min(i4.x, i4.y), min(i4.z, i4.w));\n\n  return SDF(outer / scale, inner / scale);\n}\n\n@export fn getRoundedBorderBoxSDF(box: vec2<f32>, border: vec4<f32>, radius: vec4<f32>, uv: vec2<f32>, scale: f32) -> SDF {\n\n  var flipUV = vec4<f32>(uv, 1.0 - uv);\n  var tl = flipUV.xy * box;\n  var tr = flipUV.zy * box;\n  var bl = flipUV.xw * box;\n  var br = flipUV.zw * box;\n\n  var o4 = vec4<f32>(\n    getCircleCorner(tl, radius.x),\n    getCircleCorner(tr, radius.y),\n    getCircleCorner(bl, radius.w),\n    getCircleCorner(br, radius.z),\n  );\n  var outer = min(min(o4.x, o4.y), min(o4.z, o4.w));\n\n  tl -= border.xy;\n  tr -= border.zy;\n  bl -= border.xw;\n  br -= border.zw;\n  \n  var innerRadius = max(\n    vec4<f32>(0.0),\n    radius - vec4<f32>(\n      max(border.x, border.y),\n      max(border.z, border.y),\n      max(border.x, border.w),\n      max(border.z, border.w),\n    )\n  );\n\n  var i4 = vec4<f32>(\n    getCircleCorner(tl, innerRadius.x),\n    getCircleCorner(tr, innerRadius.y),\n    getCircleCorner(bl, innerRadius.w),\n    getCircleCorner(br, innerRadius.z),\n  );\n  var inner = min(min(i4.x, i4.y), min(i4.z, i4.w));\n\n  return SDF(outer / scale, inner / scale);\n}\n\nfn getBoxCorner(xy: vec2<f32>, offset: vec2<f32>) -> f32 {\n  var clip = xy - offset;\n  return min(clip.x, clip.y);\n}\n\nfn getCircleCorner(xy: vec2<f32>, r: f32) -> f32 {\n  var clip = max(vec2<f32>(0.0), r - xy);\n  var neg = min(0.0, max(-xy.x, -xy.y) + r);\n  return r - length(clip) - neg;\n}\n",
  "geometry/anchor": "// anchor\n//\n// o--o--o-- ... --o\n// s s+1           e\n//\n// o-- ... --o--o--o\n// s           e-1 e\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@optional @link fn getAnchorStart() -> i32 { return ANCHOR_START; }\n@optional @link fn getAnchorEnd() -> i32 { return ANCHOR_END; }\n\n@export fn getLineAnchor(index: u32) -> vec4<u32> {\n  let s = getAnchorStart();\n  let e = getAnchorEnd();\n  \n  let hasBoth = s != 0 && e != 0;\n\n  var i = index;\n  var d = 0u;\n  if (hasBoth) {\n    i = i >> 1u;\n    d = i & 1u;\n  }\n\n  let n = u32(getLineDetail() + 1);\n  let start = n * i;\n  let end = start + n - 1u;\n\n  var both = 0u;\n  if (hasBoth) { both = 1u; }\n\n  if (s != 0 && (e == 0 || d == 0u)) {\n    return vec4<u32>(start, start + 1u, end, both);\n  }\n  if (e != 0 && (s == 0 || d == 1u)) {\n    return vec4<u32>(end, end - 1u, start, both);\n  }\n\n  return vec4<u32>(0u, 0u, 0u, 0u);\n};\n",
  "@use-gpu/wgsl/geometry/anchor": "// anchor\n//\n// o--o--o-- ... --o\n// s s+1           e\n//\n// o-- ... --o--o--o\n// s           e-1 e\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@optional @link fn getAnchorStart() -> i32 { return ANCHOR_START; }\n@optional @link fn getAnchorEnd() -> i32 { return ANCHOR_END; }\n\n@export fn getLineAnchor(index: u32) -> vec4<u32> {\n  let s = getAnchorStart();\n  let e = getAnchorEnd();\n  \n  let hasBoth = s != 0 && e != 0;\n\n  var i = index;\n  var d = 0u;\n  if (hasBoth) {\n    i = i >> 1u;\n    d = i & 1u;\n  }\n\n  let n = u32(getLineDetail() + 1);\n  let start = n * i;\n  let end = start + n - 1u;\n\n  var both = 0u;\n  if (hasBoth) { both = 1u; }\n\n  if (s != 0 && (e == 0 || d == 0u)) {\n    return vec4<u32>(start, start + 1u, end, both);\n  }\n  if (e != 0 && (s == 0 || d == 1u)) {\n    return vec4<u32>(end, end - 1u, start, both);\n  }\n\n  return vec4<u32>(0u, 0u, 0u, 0u);\n};\n",
  "geometry/arrow": "use '@use-gpu/wgsl/use/view'::{ getWorldScale, getViewScale };\n\nlet ARROW_ASPECT: f32 = 2.5;\n\nfn sqr(f: f32) -> f32 { return f * f; };\n\n@export fn getArrowSize(maxLength: f32, width: f32, size: f32, both: i32, w: f32, depth: f32) -> f32 {\n  if (w <= 0.0) { return 0.0; }\n  \n  let worldScale = getWorldScale(w, depth) * getViewScale();\n\n  let targetSize = size * width * worldScale * 0.5;\n  var maxSize = maxLength / ARROW_ASPECT;\n  if (both > 0) { maxSize = maxSize * 0.5; }\n\n  let ratio = maxSize / targetSize;\n  var finalSize = targetSize;\n  if (ratio < 2.0) { finalSize = targetSize * (1.0 - sqr(1.0 - ratio * 0.5)); }\n\n  return finalSize;\n};\n\n@export fn getArrowCorrection(w1: f32, w2: f32, depth: f32) -> f32 {\n  return mix(w1 / w2, 1.0, depth);\n};\n\n",
  "@use-gpu/wgsl/geometry/arrow": "use '@use-gpu/wgsl/use/view'::{ getWorldScale, getViewScale };\n\nlet ARROW_ASPECT: f32 = 2.5;\n\nfn sqr(f: f32) -> f32 { return f * f; };\n\n@export fn getArrowSize(maxLength: f32, width: f32, size: f32, both: i32, w: f32, depth: f32) -> f32 {\n  if (w <= 0.0) { return 0.0; }\n  \n  let worldScale = getWorldScale(w, depth) * getViewScale();\n\n  let targetSize = size * width * worldScale * 0.5;\n  var maxSize = maxLength / ARROW_ASPECT;\n  if (both > 0) { maxSize = maxSize * 0.5; }\n\n  let ratio = maxSize / targetSize;\n  var finalSize = targetSize;\n  if (ratio < 2.0) { finalSize = targetSize * (1.0 - sqr(1.0 - ratio * 0.5)); }\n\n  return finalSize;\n};\n\n@export fn getArrowCorrection(w1: f32, w2: f32, depth: f32) -> f32 {\n  return mix(w1 / w2, 1.0, depth);\n};\n\n",
  "geometry/face": "// segments\n//\n// .-----.\n// |     |\n// .--.--.\n//\n// 1 2 3 0 0\n//\n// triangles:\n// [0 1 2]\n// [0 2 3]\n// [0 3 4]\n\n// detail 1 = 1 tri\n@optional @link fn getFaceDetail() -> i32 { return FACE_DETAIL; }\n@export fn getFaceSegment(index: u32) -> i32 {\n  let n = u32(getFaceDetail() + 2);\n  let i = index % n;\n  if (i + 2u >= n) return 0;\n  return i + 1;\n};\n",
  "@use-gpu/wgsl/geometry/face": "// segments\n//\n// .-----.\n// |     |\n// .--.--.\n//\n// 1 2 3 0 0\n//\n// triangles:\n// [0 1 2]\n// [0 2 3]\n// [0 3 4]\n\n// detail 1 = 1 tri\n@optional @link fn getFaceDetail() -> i32 { return FACE_DETAIL; }\n@export fn getFaceSegment(index: u32) -> i32 {\n  let n = u32(getFaceDetail() + 2);\n  let i = index % n;\n  if (i + 2u >= n) return 0;\n  return i + 1;\n};\n",
  "geometry/line": "use '@use-gpu/wgsl/use/view'::{ screenToClip3D, clip3DToScreen };\n\nfn turn(xy: vec2<f32>) -> vec2<f32> {\n  return vec2<f32>(xy.y, -xy.x);\n}\n\nfn slerp(d: f32, a: vec2<f32>, b: vec2<f32>, t: f32) -> vec2<f32> {\n  var th = acos(d);\n  var ab = sin(vec2((1.0 - t) * th, t * th));\n  return normalize(a * ab.x + b * ab.y);\n}\n\n@export fn lineJoinBevel(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  if (arc > 0.0) { return right; }\n  return left;\n}\n\n@export fn lineJoinMiter(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n  var scale = 1.0;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  mid = normalize((left + right) / 2.0);\n  scale = min(2.0, 1.0 / max(0.001, dot(mid, left)));\n\n  return mid * scale;\n}\n\n@export fn lineJoinRound(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  var d = dot(left, right);\n  if (d > 0.999) { return left; }\n  return slerp(d, left, right, arc);\n}\n\n@export fn getLineJoin(\n  beforePoint: vec3<f32>,\n  centerPoint: vec3<f32>,\n  afterPoint: vec3<f32>,\n  arc: f32,\n  y: f32,\n  size: f32,\n  segment: i32,\n  style: i32,\n) -> vec3<f32> {\n  var before = clip3DToScreen(beforePoint);\n  var center = clip3DToScreen(centerPoint);\n  var after  = clip3DToScreen(afterPoint);\n\n  var left = turn(normalize(center - before));\n  var right = turn(normalize(after - center));\n\n  var mid: vec2<f32>;\n  if (segment == 2) {\n    mid = left;\n  }\n  else if (segment == 1) {\n    mid = right;\n  }\n  else {\n    if (dot(left, right) < 0.999) {\n      var c = cross(vec3(left, 0.0), vec3(right, 0.0)).z;\n      if (c * y < 0.0) {\n        mid = lineJoinMiter(left, right, segment, arc);\n      }\n      else {\n        if (style == 0) { mid = lineJoinBevel(left, right, segment, arc); }\n        if (style == 1) { mid = lineJoinMiter(left, right, segment, arc); }\n        if (style == 2) { mid = lineJoinRound(left, right, segment, arc); }\n      }\n    }\n    else {\n      mid = left;\n    }\n  }\n\n  var offset = size * mid * y;\n  center = center + offset;\n\n  return screenToClip3D(center, centerPoint.z);\n}\n",
  "@use-gpu/wgsl/geometry/line": "use '@use-gpu/wgsl/use/view'::{ screenToClip3D, clip3DToScreen };\n\nfn turn(xy: vec2<f32>) -> vec2<f32> {\n  return vec2<f32>(xy.y, -xy.x);\n}\n\nfn slerp(d: f32, a: vec2<f32>, b: vec2<f32>, t: f32) -> vec2<f32> {\n  var th = acos(d);\n  var ab = sin(vec2((1.0 - t) * th, t * th));\n  return normalize(a * ab.x + b * ab.y);\n}\n\n@export fn lineJoinBevel(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  if (arc > 0.0) { return right; }\n  return left;\n}\n\n@export fn lineJoinMiter(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n  var scale = 1.0;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  mid = normalize((left + right) / 2.0);\n  scale = min(2.0, 1.0 / max(0.001, dot(mid, left)));\n\n  return mid * scale;\n}\n\n@export fn lineJoinRound(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  var d = dot(left, right);\n  if (d > 0.999) { return left; }\n  return slerp(d, left, right, arc);\n}\n\n@export fn getLineJoin(\n  beforePoint: vec3<f32>,\n  centerPoint: vec3<f32>,\n  afterPoint: vec3<f32>,\n  arc: f32,\n  y: f32,\n  size: f32,\n  segment: i32,\n  style: i32,\n) -> vec3<f32> {\n  var before = clip3DToScreen(beforePoint);\n  var center = clip3DToScreen(centerPoint);\n  var after  = clip3DToScreen(afterPoint);\n\n  var left = turn(normalize(center - before));\n  var right = turn(normalize(after - center));\n\n  var mid: vec2<f32>;\n  if (segment == 2) {\n    mid = left;\n  }\n  else if (segment == 1) {\n    mid = right;\n  }\n  else {\n    if (dot(left, right) < 0.999) {\n      var c = cross(vec3(left, 0.0), vec3(right, 0.0)).z;\n      if (c * y < 0.0) {\n        mid = lineJoinMiter(left, right, segment, arc);\n      }\n      else {\n        if (style == 0) { mid = lineJoinBevel(left, right, segment, arc); }\n        if (style == 1) { mid = lineJoinMiter(left, right, segment, arc); }\n        if (style == 2) { mid = lineJoinRound(left, right, segment, arc); }\n      }\n    }\n    else {\n      mid = left;\n    }\n  }\n\n  var offset = size * mid * y;\n  center = center + offset;\n\n  return screenToClip3D(center, centerPoint.z);\n}\n",
  "geometry/quad": "let QUAD: array<vec2<u32>, 4> = array<vec2<u32>, 4>(\n  vec2<u32>(0u, 0u),\n  vec2<u32>(1u, 0u),\n  vec2<u32>(0u, 1u),\n  vec2<u32>(1u, 1u),\n);\n\n@export fn getQuadIndex(vertex: u32) -> vec2<u32> {\n  return QUAD[vertex];\n}\n\n@export fn getQuadUV(vertex: u32) -> vec2<f32> {\n  return vec2<f32>(getQuadIndex(vertex));\n}\n\n",
  "@use-gpu/wgsl/geometry/quad": "let QUAD: array<vec2<u32>, 4> = array<vec2<u32>, 4>(\n  vec2<u32>(0u, 0u),\n  vec2<u32>(1u, 0u),\n  vec2<u32>(0u, 1u),\n  vec2<u32>(1u, 1u),\n);\n\n@export fn getQuadIndex(vertex: u32) -> vec2<u32> {\n  return QUAD[vertex];\n}\n\n@export fn getQuadUV(vertex: u32) -> vec2<f32> {\n  return vec2<f32>(getQuadIndex(vertex));\n}\n\n",
  "geometry/segment": "// segments\n//\n// o--o--o  o--o--o--o  o--o\n// 1  3  2  1  3  3  2  1  2\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@export fn getLineSegment(index: u32) -> i32 {\n  let n = u32(getLineDetail() + 1);\n  let i = index % n;\n  if (i == 0u) { return 1; }\n  if (i == n - 1u) { return 2; }\n  return 3;\n};\n",
  "@use-gpu/wgsl/geometry/segment": "// segments\n//\n// o--o--o  o--o--o--o  o--o\n// 1  3  2  1  3  3  2  1  2\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@export fn getLineSegment(index: u32) -> i32 {\n  let n = u32(getLineDetail() + 1);\n  let i = index % n;\n  if (i == 0u) { return 1; }\n  if (i == n - 1u) { return 2; }\n  return 3;\n};\n",
  "geometry/strip": "@export fn getStripIndex(vertex: u32) -> vec2<u32> {\n  var x = vertex >> 1u;\n  var y = vertex & 1u;\n  return vec2<u32>(x, y);\n}\n\n@export fn getStripUV(vertex: u32) -> vec2<f32> {\n  return vec2<f32>(getStripIndex(vertex));\n}\n\n",
  "@use-gpu/wgsl/geometry/strip": "@export fn getStripIndex(vertex: u32) -> vec2<u32> {\n  var x = vertex >> 1u;\n  var y = vertex & 1u;\n  return vec2<u32>(x, y);\n}\n\n@export fn getStripUV(vertex: u32) -> vec2<f32> {\n  return vec2<f32>(getStripIndex(vertex));\n}\n\n",
  "geometry/trim": "// trim\n//\n// o--o--o  o--o--o--o\n// \n// 0  0  0  3  3  3  3\n// 2  2  2  6  6  6  6\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@optional @link fn getAnchorStart() -> i32 { return ANCHOR_START; }\n@optional @link fn getAnchorEnd() -> i32 { return ANCHOR_END; }\n\n@export fn getLineTrim(index: u32) -> vec4<u32> {\n  let s = getAnchorStart();\n  let e = getAnchorEnd();\n\n  let n = u32(getLineDetail() + 1);\n\n  let i = index / n;\n  let d = index % n;\n  \n  let start = i * n;\n  let end = start + n - 1u;\n\n  var bits = 0u;\n  if (s != 0) { bits += 1u; }\n  if (e != 0) { bits += 2u; }\n\n  return vec4<u32>(start, end, bits, 0u);\n};\n",
  "@use-gpu/wgsl/geometry/trim": "// trim\n//\n// o--o--o  o--o--o--o\n// \n// 0  0  0  3  3  3  3\n// 2  2  2  6  6  6  6\n\n@optional @link fn getLineDetail() -> i32 { return LINE_DETAIL; }\n@optional @link fn getAnchorStart() -> i32 { return ANCHOR_START; }\n@optional @link fn getAnchorEnd() -> i32 { return ANCHOR_END; }\n\n@export fn getLineTrim(index: u32) -> vec4<u32> {\n  let s = getAnchorStart();\n  let e = getAnchorEnd();\n\n  let n = u32(getLineDetail() + 1);\n\n  let i = index / n;\n  let d = index % n;\n  \n  let start = i * n;\n  let end = start + n - 1u;\n\n  var bits = 0u;\n  if (s != 0) { bits += 1u; }\n  if (e != 0) { bits += 2u; }\n\n  return vec4<u32>(start, end, bits, 0u);\n};\n",
  "instance/fragment/mapped": "use '@use-gpu/wgsl/use/view'::{ getViewPosition };\nuse '@use-gpu/wgsl/material/pbr'::{ applyPBRMaterial as applyDefaultPBRMaterial };\n\n@optional @link fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  return applyDefaultPBRMaterial(materialColor, lightColor, mapUV, N, L, V);\n}\n\n@optional @link fn getNormal(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 0.0); };\n@optional @link fn getOcclusion(uv: vec2<f32>) -> f32 { return 1.0; };\n@optional @link fn getEmissive(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0); };\n\n@export fn getMappedFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  position: vec4<f32>,\n) -> vec4<f32> {\n\n  let viewPosition = getViewPosition().xyz;\n  let toView: vec3<f32> = viewPosition - position.xyz;\n\n  let tangentNormal = getNormal(uv) * 2.0 - 1.0;\n  let occlusion = getOcclusion(uv);\n  let emissive = getEmissive(uv);\n  \n  let bitangent = cross(normal.xyz, tangent.xyz) * tangent.w;\n  let bumpNormal = normalize(\n    tangentNormal.x * tangent.xyz +\n    tangentNormal.y * bitangent +\n    tangentNormal.z * normal.xyz\n  );\n\n  let N: vec3<f32> = normalize(bumpNormal);\n  let V: vec3<f32> = normalize(toView);\n\n  let lightPosition = vec3<f32>(10.0, 30.0, 20.0);\n  let lightColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n  let lightAmbient = 0.005;\n\n  let toLight: vec3<f32> = lightPosition - position.xyz;\n  let L: vec3<f32> = normalize(toLight);\n\n  let direct = emissive.xyz + applyPBRMaterial(color, lightColor, uv, N, L, V);\n  let indirect = vec3<f32>(occlusion * lightAmbient);\n\n  return vec4<f32>((direct + indirect) * color.a, color.a);\n}\n\n/*\nfn toDerivative(normal: vec3<f32>) -> vec2<f32> { return -normal.xy / normal.z; }\n\nfn getBasis(normal: vec3<f32> uv: vec2<f32>) -> mat3x2<f32> {\n  let sigmaS = dpdxFine(uv);\n  let sigmaT = dpdyFine(uv);\n\n  let det = dot(dx, vec2<f32>(dy.y, -dy.x));\n  let detSign = det < 0.0 ? -1.0 : 1.0;\n  \n  let invC0 = detSign * vec2<f32>(dy.y, -dx.y); // ???\n  var vT = sigmaX * invC0.x + signaY * invC0.y;\n  if (abs(det) > 0.0) vT = normalize(vT);\n\n  var vB = (detSign * flipSign) * cross(normal, vT);\n  return mat3x2<f32>(vT, vB);\n}\n*/\n",
  "@use-gpu/wgsl/instance/fragment/mapped": "use '@use-gpu/wgsl/use/view'::{ getViewPosition };\nuse '@use-gpu/wgsl/material/pbr'::{ applyPBRMaterial as applyDefaultPBRMaterial };\n\n@optional @link fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  return applyDefaultPBRMaterial(materialColor, lightColor, mapUV, N, L, V);\n}\n\n@optional @link fn getNormal(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 0.0); };\n@optional @link fn getOcclusion(uv: vec2<f32>) -> f32 { return 1.0; };\n@optional @link fn getEmissive(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0); };\n\n@export fn getMappedFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  position: vec4<f32>,\n) -> vec4<f32> {\n\n  let viewPosition = getViewPosition().xyz;\n  let toView: vec3<f32> = viewPosition - position.xyz;\n\n  let tangentNormal = getNormal(uv) * 2.0 - 1.0;\n  let occlusion = getOcclusion(uv);\n  let emissive = getEmissive(uv);\n  \n  let bitangent = cross(normal.xyz, tangent.xyz) * tangent.w;\n  let bumpNormal = normalize(\n    tangentNormal.x * tangent.xyz +\n    tangentNormal.y * bitangent +\n    tangentNormal.z * normal.xyz\n  );\n\n  let N: vec3<f32> = normalize(bumpNormal);\n  let V: vec3<f32> = normalize(toView);\n\n  let lightPosition = vec3<f32>(10.0, 30.0, 20.0);\n  let lightColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n  let lightAmbient = 0.005;\n\n  let toLight: vec3<f32> = lightPosition - position.xyz;\n  let L: vec3<f32> = normalize(toLight);\n\n  let direct = emissive.xyz + applyPBRMaterial(color, lightColor, uv, N, L, V);\n  let indirect = vec3<f32>(occlusion * lightAmbient);\n\n  return vec4<f32>((direct + indirect) * color.a, color.a);\n}\n\n/*\nfn toDerivative(normal: vec3<f32>) -> vec2<f32> { return -normal.xy / normal.z; }\n\nfn getBasis(normal: vec3<f32> uv: vec2<f32>) -> mat3x2<f32> {\n  let sigmaS = dpdxFine(uv);\n  let sigmaT = dpdyFine(uv);\n\n  let det = dot(dx, vec2<f32>(dy.y, -dy.x));\n  let detSign = det < 0.0 ? -1.0 : 1.0;\n  \n  let invC0 = detSign * vec2<f32>(dy.y, -dx.y); // ???\n  var vT = sigmaX * invC0.x + signaY * invC0.y;\n  if (abs(det) > 0.0) vT = normalize(vT);\n\n  var vB = (detSign * flipSign) * cross(normal, vT);\n  return mat3x2<f32>(vT, vB);\n}\n*/\n",
  "instance/fragment/shaded": "use '@use-gpu/wgsl/use/view'::{ getViewPosition };\nuse '@use-gpu/wgsl/material/pbr'::{ applyPBRMaterial as applyDefaultPBRMaterial };\n\n@optional @link fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  return applyDefaultPBRMaterial(materialColor, lightColor, mapUV, N, L, V);\n}\n\n@export fn getShadedFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  position: vec4<f32>,\n) -> vec4<f32> {\n  let viewPosition = getViewPosition();\n  let toView: vec3<f32> = viewPosition.xyz - position.xyz;\n\n  let N: vec3<f32> = normalize(normal.xyz);\n  let V: vec3<f32> = normalize(toView);\n\n  let lightPosition = vec3<f32>(10.0, 30.0, 20.0);\n  let lightColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n\n  let toLight: vec3<f32> = lightPosition - position.xyz;\n  let L: vec3<f32> = normalize(toLight);\n\n  let direct = applyPBRMaterial(color, lightColor, uv, N, L, V);\n  return vec4<f32>(direct * color.a, color.a);\n}\n",
  "@use-gpu/wgsl/instance/fragment/shaded": "use '@use-gpu/wgsl/use/view'::{ getViewPosition };\nuse '@use-gpu/wgsl/material/pbr'::{ applyPBRMaterial as applyDefaultPBRMaterial };\n\n@optional @link fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  return applyDefaultPBRMaterial(materialColor, lightColor, mapUV, N, L, V);\n}\n\n@export fn getShadedFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  position: vec4<f32>,\n) -> vec4<f32> {\n  let viewPosition = getViewPosition();\n  let toView: vec3<f32> = viewPosition.xyz - position.xyz;\n\n  let N: vec3<f32> = normalize(normal.xyz);\n  let V: vec3<f32> = normalize(toView);\n\n  let lightPosition = vec3<f32>(10.0, 30.0, 20.0);\n  let lightColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n\n  let toLight: vec3<f32> = lightPosition - position.xyz;\n  let L: vec3<f32> = normalize(toLight);\n\n  let direct = applyPBRMaterial(color, lightColor, uv, N, L, V);\n  return vec4<f32>(direct * color.a, color.a);\n}\n",
  "instance/fragment/ui": "use '@use-gpu/wgsl/fragment/sdf-2d'::{ SDF, getUVScale, getBoxSDF, getBorderBoxSDF, getRoundedBorderBoxSDF };\nuse '@use-gpu/wgsl/use/color'::{ premultiply };\n\n@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n\n@export fn getUIFragment(\n  uv: vec2<f32>,\n  textureUV: vec2<f32>,\n  clipUV: vec4<f32>,\n  sdfUV: vec2<f32>,\n  sdfConfig: vec4<f32>,\n  repeat: i32,\n  mode: i32,\n  layout: vec4<f32>,\n  radius: vec4<f32>,\n  border: vec4<f32>,\n  stroke: vec4<f32>,\n  fill: vec4<f32>,\n) -> vec4<f32> {\n  var fillColor = fill;\n  var strokeColor = stroke;\n\n  var scale = getUVScale(sdfUV);\n\n  var sdf: SDF;\n  var texture = getTexture(textureUV);\n  var sdfRaw = 0.0;\n  var mark = 0.0;\n\n  if (uv.x < clipUV.x || uv.y < clipUV.y || uv.x > clipUV.z || uv.y > clipUV.w) { discard; }\n\n  if (mode == -1 || mode == -2) {\n    // SDF Glyph\n    let sdfRadius = sdfConfig.x;\n    var expand = border.x;\n    var bleed = border.y;\n    \n    var d = (texture.a - 0.75) * sdfRadius;\n    var s = (d + expand / sdfConfig.y) / scale + 0.5 + bleed;\n    sdf = SDF(s, s);\n    \n    if (mode == -2) {\n      fillColor = vec4<f32>(texture.rgb, fillColor.a);\n    }\n  }\n  else {\n    // Textured box\n    if (texture.a > 0.0) {\n      if (\n        ((repeat == 0 || repeat == 1) && (textureUV.x < 0.0 || textureUV.x > 1.0)) ||\n        ((repeat == 0 || repeat == 2) && (textureUV.y < 0.0 || textureUV.y > 1.0))\n      ) {\n        texture.a = 0.0;\n      }\n\n      if (texture.a > 0.0) {\n        fillColor = vec4<f32>(\n          premultiply(fillColor).rgb * (1.0 - texture.a) + texture.rgb,\n          mix(fillColor.a, 1.0, texture.a),\n        );\n      }\n    }\n    else {\n      fillColor = premultiply(fillColor);\n    }\n  \n    // Get appropriate SDF\n    if (mode == 0) {\n      if (fillColor.a <= 0.0) { discard; }\n      sdf = getBoxSDF(layout.xy, uv, scale);\n    }\n    else if (mode == 1) { sdf = getBorderBoxSDF(layout.xy, border, uv, scale); }\n    else { sdf = getRoundedBorderBoxSDF(layout.xy, border, radius, uv, scale); }\n\n    // Bleed by 0.5px to account for filter radius\n    let bleed = 0.5;\n    sdf.outer += bleed;\n    sdf.inner += bleed;\n  }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n\n  // SDF iso-contours\n  if (DEBUG_SDF) {\n    var s = 4.0;\n    var b = 0.0;\n    if (mode == -1 || mode == -2) {\n      s = 1.0;\n      b = 6.0;\n    }\n\n    let o = (sdf.outer - 0.5) * scale / s;\n    var m = (max(0.0, o + 0.5 + b) % 1.0) - 0.5;\n    if (o < -b) { m = 1.0 + (o + b - 1.0); }\n    mark = clamp(1.0 - abs(m / scale) * s, 0.0, 1.0);\n    \n    if ((border.x != border.y) || (border.z != border.w) || (border.x != border.z)) {\n      let o = (sdf.inner - 0.5) * scale / s;\n      let m = ((o + 0.5 + b) % 1.0) - 0.5;\n      let mark2 = 1.0 * clamp(1.0 - abs(m / scale) * s, 0.0, 1.0);\n      \n      if (sdf.inner > -0.5) { mark = mark2 + mark * 0.5; }\n    }\n  }\n  if (mask == 0.0 && mark == 0.0) { discard; }\n\n  // Blend stroke/fill\n  var color = fillColor;\n  if (sdf.outer != sdf.inner) {\n    // If less than 1px border, render 1px with opacity instead\n    var reduce = 1.0;\n    if (sdf.outer - sdf.inner < 1.0) {\n      reduce = sdf.outer - sdf.inner;\n      sdf.inner = sdf.outer - 1.0;\n    }\n    color = mix(fillColor, strokeColor, reduce * clamp(1.0 - sdf.inner, 0.0, 1.0));\n  }\n\n  if (!HAS_ALPHA_TO_COVERAGE) {\n    color = vec4<f32>((color.rgb + mark) * color.a * mask, color.a * mask + mark);\n  }\n  else {\n    color = vec4<f32>(color.rgb + mark, color.a * mask);\n  }\n\n  if (DEBUG_SDF) {\n    return vec4<f32>(mix(color.rgb, vec3<f32>(mark), 0.5), color.a);\n  }\n  return color;\n}\n",
  "@use-gpu/wgsl/instance/fragment/ui": "use '@use-gpu/wgsl/fragment/sdf-2d'::{ SDF, getUVScale, getBoxSDF, getBorderBoxSDF, getRoundedBorderBoxSDF };\nuse '@use-gpu/wgsl/use/color'::{ premultiply };\n\n@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n\n@export fn getUIFragment(\n  uv: vec2<f32>,\n  textureUV: vec2<f32>,\n  clipUV: vec4<f32>,\n  sdfUV: vec2<f32>,\n  sdfConfig: vec4<f32>,\n  repeat: i32,\n  mode: i32,\n  layout: vec4<f32>,\n  radius: vec4<f32>,\n  border: vec4<f32>,\n  stroke: vec4<f32>,\n  fill: vec4<f32>,\n) -> vec4<f32> {\n  var fillColor = fill;\n  var strokeColor = stroke;\n\n  var scale = getUVScale(sdfUV);\n\n  var sdf: SDF;\n  var texture = getTexture(textureUV);\n  var sdfRaw = 0.0;\n  var mark = 0.0;\n\n  if (uv.x < clipUV.x || uv.y < clipUV.y || uv.x > clipUV.z || uv.y > clipUV.w) { discard; }\n\n  if (mode == -1 || mode == -2) {\n    // SDF Glyph\n    let sdfRadius = sdfConfig.x;\n    var expand = border.x;\n    var bleed = border.y;\n    \n    var d = (texture.a - 0.75) * sdfRadius;\n    var s = (d + expand / sdfConfig.y) / scale + 0.5 + bleed;\n    sdf = SDF(s, s);\n    \n    if (mode == -2) {\n      fillColor = vec4<f32>(texture.rgb, fillColor.a);\n    }\n  }\n  else {\n    // Textured box\n    if (texture.a > 0.0) {\n      if (\n        ((repeat == 0 || repeat == 1) && (textureUV.x < 0.0 || textureUV.x > 1.0)) ||\n        ((repeat == 0 || repeat == 2) && (textureUV.y < 0.0 || textureUV.y > 1.0))\n      ) {\n        texture.a = 0.0;\n      }\n\n      if (texture.a > 0.0) {\n        fillColor = vec4<f32>(\n          premultiply(fillColor).rgb * (1.0 - texture.a) + texture.rgb,\n          mix(fillColor.a, 1.0, texture.a),\n        );\n      }\n    }\n    else {\n      fillColor = premultiply(fillColor);\n    }\n  \n    // Get appropriate SDF\n    if (mode == 0) {\n      if (fillColor.a <= 0.0) { discard; }\n      sdf = getBoxSDF(layout.xy, uv, scale);\n    }\n    else if (mode == 1) { sdf = getBorderBoxSDF(layout.xy, border, uv, scale); }\n    else { sdf = getRoundedBorderBoxSDF(layout.xy, border, radius, uv, scale); }\n\n    // Bleed by 0.5px to account for filter radius\n    let bleed = 0.5;\n    sdf.outer += bleed;\n    sdf.inner += bleed;\n  }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n\n  // SDF iso-contours\n  if (DEBUG_SDF) {\n    var s = 4.0;\n    var b = 0.0;\n    if (mode == -1 || mode == -2) {\n      s = 1.0;\n      b = 6.0;\n    }\n\n    let o = (sdf.outer - 0.5) * scale / s;\n    var m = (max(0.0, o + 0.5 + b) % 1.0) - 0.5;\n    if (o < -b) { m = 1.0 + (o + b - 1.0); }\n    mark = clamp(1.0 - abs(m / scale) * s, 0.0, 1.0);\n    \n    if ((border.x != border.y) || (border.z != border.w) || (border.x != border.z)) {\n      let o = (sdf.inner - 0.5) * scale / s;\n      let m = ((o + 0.5 + b) % 1.0) - 0.5;\n      let mark2 = 1.0 * clamp(1.0 - abs(m / scale) * s, 0.0, 1.0);\n      \n      if (sdf.inner > -0.5) { mark = mark2 + mark * 0.5; }\n    }\n  }\n  if (mask == 0.0 && mark == 0.0) { discard; }\n\n  // Blend stroke/fill\n  var color = fillColor;\n  if (sdf.outer != sdf.inner) {\n    // If less than 1px border, render 1px with opacity instead\n    var reduce = 1.0;\n    if (sdf.outer - sdf.inner < 1.0) {\n      reduce = sdf.outer - sdf.inner;\n      sdf.inner = sdf.outer - 1.0;\n    }\n    color = mix(fillColor, strokeColor, reduce * clamp(1.0 - sdf.inner, 0.0, 1.0));\n  }\n\n  if (!HAS_ALPHA_TO_COVERAGE) {\n    color = vec4<f32>((color.rgb + mark) * color.a * mask, color.a * mask + mark);\n  }\n  else {\n    color = vec4<f32>(color.rgb + mark, color.a * mask);\n  }\n\n  if (DEBUG_SDF) {\n    return vec4<f32>(mix(color.rgb, vec3<f32>(mark), 0.5), color.a);\n  }\n  return color;\n}\n",
  "instance/identity": "@export fn getIndex(i: u32) -> { return i; }",
  "@use-gpu/wgsl/instance/identity": "@export fn getIndex(i: u32) -> { return i; }",
  "instance/interleave": "@optional @link fn getOffset() -> u32 { return 0u };\n@optional @link fn getSize() -> u32 { return 1u };\n\n@export fn getIndex(i: u32) -> u32 {\n  return i * getSize() + getOffset();\n}\n",
  "@use-gpu/wgsl/instance/interleave": "@optional @link fn getOffset() -> u32 { return 0u };\n@optional @link fn getSize() -> u32 { return 1u };\n\n@export fn getIndex(i: u32) -> u32 {\n  return i * getSize() + getOffset();\n}\n",
  "instance/vertex/arrow": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D };\nuse '@use-gpu/wgsl/geometry/arrow'::{ getArrowSize, getArrowCorrection };\n\n@optional @link fn getVertex(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n\n@optional @link fn getAnchor(i: u32) -> vec4<u32> { return vec4<u32>(0u, 1u, 0u, 0u); };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getSize(i: u32) -> f32 { return 3.0; };\n@optional @link fn getWidth(i: u32) -> f32 { return 1.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n  \nlet ARROW_ASPECT: f32 = 2.5;\n\n@export fn getArrowVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  let meshPosition = getVertex(vertexIndex);\n  \n  let anchor = getAnchor(instanceIndex);\n  let anchorIndex = anchor.x;\n  let nextIndex = anchor.y;\n  let endIndex = anchor.z;\n  let both = i32(anchor.w);\n  \n  let color = getColor(anchorIndex);\n  let size = getSize(anchorIndex);\n  let width = getWidth(anchorIndex);\n  let depth = getDepth(anchorIndex);\n\n  let startPos = getPosition(anchorIndex);\n  let nextPos = getPosition(nextIndex);\n  let midPos = getPosition((anchorIndex + endIndex) / 2u);\n  let endPos = getPosition(endIndex);\n\n  let center = worldToClip(startPos);\n\n  let maxLength = length(endPos.xyz - midPos.xyz) + length(midPos.xyz - startPos.xyz);\n  let arrowSize = getArrowSize(maxLength, width, size, both, center.w, depth);\n\n  let t = normalize(nextPos.xyz - startPos.xyz);\n\n  var u: vec3<f32>;\n  if (abs(t.z) > 0.5) { u = vec3<f32>(1.0, 0.0, 0.0); }\n  else { u = vec3<f32>(0.0, 0.0, 1.0); };\n\n  let n = normalize(cross(t, u));\n  let b = cross(t, n);\n\n  let m = mat4x4<f32>(\n    vec4<f32>(t.xyz, 0.0),\n    vec4<f32>(b.xyz, 0.0),\n    vec4<f32>(n.xyz, 0.0),\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  );\n\n  let offset = vec4<f32>(t.xyz, 0.0) * (ARROW_ASPECT * arrowSize);\n  let cap = worldToClip(startPos + offset);\n  \n  var arrowRadius = 1.0;\n  if (cap.w > 0.0 && center.w > 0.0) {\n    arrowRadius = getArrowCorrection(cap.w, center.w, depth);\n  }\n\n  let uv = vec2<f32>(f32(anchorIndex), 0.0);\n\n  let orientedPos = m * vec4<f32>(vec3<f32>(meshPosition.x, meshPosition.yz * arrowRadius) * arrowSize, 1.0);\n  let finalPos = vec4<f32>(orientedPos.xyz + startPos.xyz, 1.0);\n  var position = worldToClip(finalPos);\n  \n  return SolidVertex(\n    position,\n    color,\n    uv,\n    getLookup(anchorIndex),\n  );\n}\n",
  "@use-gpu/wgsl/instance/vertex/arrow": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D };\nuse '@use-gpu/wgsl/geometry/arrow'::{ getArrowSize, getArrowCorrection };\n\n@optional @link fn getVertex(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n\n@optional @link fn getAnchor(i: u32) -> vec4<u32> { return vec4<u32>(0u, 1u, 0u, 0u); };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getSize(i: u32) -> f32 { return 3.0; };\n@optional @link fn getWidth(i: u32) -> f32 { return 1.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n  \nlet ARROW_ASPECT: f32 = 2.5;\n\n@export fn getArrowVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  let meshPosition = getVertex(vertexIndex);\n  \n  let anchor = getAnchor(instanceIndex);\n  let anchorIndex = anchor.x;\n  let nextIndex = anchor.y;\n  let endIndex = anchor.z;\n  let both = i32(anchor.w);\n  \n  let color = getColor(anchorIndex);\n  let size = getSize(anchorIndex);\n  let width = getWidth(anchorIndex);\n  let depth = getDepth(anchorIndex);\n\n  let startPos = getPosition(anchorIndex);\n  let nextPos = getPosition(nextIndex);\n  let midPos = getPosition((anchorIndex + endIndex) / 2u);\n  let endPos = getPosition(endIndex);\n\n  let center = worldToClip(startPos);\n\n  let maxLength = length(endPos.xyz - midPos.xyz) + length(midPos.xyz - startPos.xyz);\n  let arrowSize = getArrowSize(maxLength, width, size, both, center.w, depth);\n\n  let t = normalize(nextPos.xyz - startPos.xyz);\n\n  var u: vec3<f32>;\n  if (abs(t.z) > 0.5) { u = vec3<f32>(1.0, 0.0, 0.0); }\n  else { u = vec3<f32>(0.0, 0.0, 1.0); };\n\n  let n = normalize(cross(t, u));\n  let b = cross(t, n);\n\n  let m = mat4x4<f32>(\n    vec4<f32>(t.xyz, 0.0),\n    vec4<f32>(b.xyz, 0.0),\n    vec4<f32>(n.xyz, 0.0),\n    vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  );\n\n  let offset = vec4<f32>(t.xyz, 0.0) * (ARROW_ASPECT * arrowSize);\n  let cap = worldToClip(startPos + offset);\n  \n  var arrowRadius = 1.0;\n  if (cap.w > 0.0 && center.w > 0.0) {\n    arrowRadius = getArrowCorrection(cap.w, center.w, depth);\n  }\n\n  let uv = vec2<f32>(f32(anchorIndex), 0.0);\n\n  let orientedPos = m * vec4<f32>(vec3<f32>(meshPosition.x, meshPosition.yz * arrowRadius) * arrowSize, 1.0);\n  let finalPos = vec4<f32>(orientedPos.xyz + startPos.xyz, 1.0);\n  var position = worldToClip(finalPos);\n  \n  return SolidVertex(\n    position,\n    color,\n    uv,\n    getLookup(anchorIndex),\n  );\n}\n",
  "instance/vertex/face": "use '@use-gpu/wgsl/use/types'::{ ShadedVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, getViewPosition };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getNormal(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n@optional @link fn getTangent(i: u32) -> vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); };\n@optional @link fn getUV(i: u32) -> vec2<f32> { return vec2<f32>(0.5, 0.5); };\n@optional @link fn getSegment(i: u32) -> i32 { return -1; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n\n@optional @link fn getIndex(i: u32) -> u32 { return 0u; };\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n\n@export fn getFaceVertex(vertexIndex: u32, instanceIndex: u32) -> ShadedVertex {\n  let NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  let segment = getSegment(instanceIndex);\n  let index = instanceIndex * 3u + vertexIndex;\n  \n  var cornerIndex: u32;\n  var unweldedIndex: u32;\n  if (HAS_INDICES) {\n    // Indexed geometry\n    cornerIndex = getIndex(index);\n    unweldedIndex = index;\n  }\n  else if (segment == -1) {\n    // Loose triangles\n    cornerIndex = index;\n    unweldedIndex = index;\n  }\n  else if (segment == 0) {\n    // Spacer null triangle\n    return ShadedVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN),\n      0u,\n    );\n  }\n  else {\n    // Triangle fan\n    if (vertexIndex == 0u) { cornerIndex = instanceIndex - u32(segment - 1); }\n    else if (vertexIndex == 1u) { cornerIndex = instanceIndex + 1u; }\n    else { cornerIndex = instanceIndex + 2u; }\n    unweldedIndex = cornerIndex;\n  }\n\n  var normalIndex = cornerIndex;\n  var tangentIndex = cornerIndex;\n  if (UNWELDED_NORMALS) { normalIndex = unweldedIndex; }\n  if (UNWELDED_TANGENTS) { tangentIndex = unweldedIndex; }\n\n  var color = getColor(cornerIndex);\n  var world = getPosition(cornerIndex);\n  var normal = getNormal(normalIndex);\n  var tangent = getTangent(tangentIndex);\n  var uv = getUV(cornerIndex);\n\n  var position = worldToClip(world);\n\n  return ShadedVertex(\n    position,\n    world,\n    normal,\n    tangent,\n    color,\n    uv,\n    getLookup(cornerIndex),\n  );\n}\n",
  "@use-gpu/wgsl/instance/vertex/face": "use '@use-gpu/wgsl/use/types'::{ ShadedVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, getViewPosition };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getNormal(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n@optional @link fn getTangent(i: u32) -> vec4<f32> { return vec4<f32>(1.0, 0.0, 0.0, 1.0); };\n@optional @link fn getUV(i: u32) -> vec2<f32> { return vec2<f32>(0.5, 0.5); };\n@optional @link fn getSegment(i: u32) -> i32 { return -1; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n\n@optional @link fn getIndex(i: u32) -> u32 { return 0u; };\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n\n@export fn getFaceVertex(vertexIndex: u32, instanceIndex: u32) -> ShadedVertex {\n  let NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  let segment = getSegment(instanceIndex);\n  let index = instanceIndex * 3u + vertexIndex;\n  \n  var cornerIndex: u32;\n  var unweldedIndex: u32;\n  if (HAS_INDICES) {\n    // Indexed geometry\n    cornerIndex = getIndex(index);\n    unweldedIndex = index;\n  }\n  else if (segment == -1) {\n    // Loose triangles\n    cornerIndex = index;\n    unweldedIndex = index;\n  }\n  else if (segment == 0) {\n    // Spacer null triangle\n    return ShadedVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN),\n      0u,\n    );\n  }\n  else {\n    // Triangle fan\n    if (vertexIndex == 0u) { cornerIndex = instanceIndex - u32(segment - 1); }\n    else if (vertexIndex == 1u) { cornerIndex = instanceIndex + 1u; }\n    else { cornerIndex = instanceIndex + 2u; }\n    unweldedIndex = cornerIndex;\n  }\n\n  var normalIndex = cornerIndex;\n  var tangentIndex = cornerIndex;\n  if (UNWELDED_NORMALS) { normalIndex = unweldedIndex; }\n  if (UNWELDED_TANGENTS) { tangentIndex = unweldedIndex; }\n\n  var color = getColor(cornerIndex);\n  var world = getPosition(cornerIndex);\n  var normal = getNormal(normalIndex);\n  var tangent = getTangent(tangentIndex);\n  var uv = getUV(cornerIndex);\n\n  var position = worldToClip(world);\n\n  return ShadedVertex(\n    position,\n    world,\n    normal,\n    tangent,\n    color,\n    uv,\n    getLookup(cornerIndex),\n  );\n}\n",
  "instance/vertex/full-screen": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ getViewSize };\n\n//  0        1      2\n//    +------.------/\n//    |      .    /\n//    |      .  / \n//  1 ......../ \n//    |     /\n//    |   /\n//    | /\n//  2 /\n\n@export fn getFullScreenVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var c = getViewSize(); // Ensure view uniforms are used\n\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  return SolidVertex(\n    vec4<f32>(xy.x * 2.0 + 1.0, -(xy.y * 2.0 + 1.0), 0.5, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    uv * 2.0,\n    instanceIndex,\n  );\n}",
  "@use-gpu/wgsl/instance/vertex/full-screen": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ getViewSize };\n\n//  0        1      2\n//    +------.------/\n//    |      .    /\n//    |      .  / \n//  1 ......../ \n//    |     /\n//    |   /\n//    | /\n//  2 /\n\n@export fn getFullScreenVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var c = getViewSize(); // Ensure view uniforms are used\n\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  return SolidVertex(\n    vec4<f32>(xy.x * 2.0 + 1.0, -(xy.y * 2.0 + 1.0), 0.5, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    uv * 2.0,\n    instanceIndex,\n  );\n}",
  "instance/vertex/label": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ getViewResolution, worldToClip, getPerspectiveScale }; \n\n@optional @link fn getIndex(i: u32) -> u32 { return 0u; };\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(-1.0, -1.0, 1.0, 1.0); };\n@optional @link fn getUV(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n@optional @link fn getLayout(i: u32) -> vec2<f32> { return vec2<f32>(0.0, 0.0); };\n\n@optional @link fn getSDFConfig(i: u32) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 16.0, 0.0); };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getPlacement(i: u32) -> vec2<f32> { return vec2<f32>(0.0, 0.0); };\n@optional @link fn getOffset(i: u32) -> f32 { return 0.0; };\n@optional @link fn getSize(i: u32) -> f32 { return 16.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getExpand(i: u32) -> f32 { return 0.0; };\n@optional @link fn getFlip(i: u32) -> vec2<f32> { return vec2<f32>(1.0, 1.0); };\n\n@export fn getLabelVertex(vertexIndex: u32, instanceIndex: u32) -> UIVertex {\n\n  var sdfConfig = getSDFConfig(instanceIndex);\n  var fontSize = sdfConfig.z;\n\n  var index = getIndex(instanceIndex);\n  var rectangle = getRectangle(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n\n  var flip = getFlip(index);\n\n  var position = getPosition(index);\n  var placement = getPlacement(index) * flip;\n  var layout = getLayout(index);\n  var offset = getOffset(index);\n  var size = getSize(index);\n  var depth = getDepth(index);\n  var color = getColor(index);\n  var expand = getExpand(index);\n\n  var center = worldToClip(position);\n  \n  // Lay out quad\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  var origin = ((placement - 1.0) * 0.5 * layout) + (offset * placement);\n\n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n\n  // Factor in relative font and atlas scale\n  var glyphScale = size / fontSize;\n  var finalScale = pixelScale * glyphScale;\n\n  // Apply half pixel edge bleed on XY and UV\n  var xy: vec2<f32>;\n  var uv: vec2<f32>;\n  /*\n  if (HAS_EDGE_BLEED) {\n    let bleed = 0.5;\n    var ul = (rectangle.xy + origin) * finalScale - bleed;\n    var br = (rectangle.zw + origin) * finalScale + bleed;\n    var wh = (rectangle.zw - rectangle.xy) * finalScale;\n\n    xy = mix(ul, br, uv1);\n    uv = mix(uv4.xy, uv4.zw, uv1 + xy1 * bleed / wh);\n  }\n  else {\n  */\n    xy = mix(rectangle.xy + origin, rectangle.zw + origin, uv1) * finalScale;\n    uv = mix(uv4.xy, uv4.zw, uv1);\n  // }\n\n  xy = xy * flip;\n\n  // Attach to position\n  center = vec4<f32>(center.xy + 2.0 * xy * getViewResolution() * center.w, center.zw);\n  \n  let sdfUV = uv;\n  let textureUV = uv;\n  let clipUV = vec4<f32>(0.0, 0.0, 1.0, 1.0);\n\n  return UIVertex(\n    center,\n    uv1,\n    sdfConfig,\n    sdfUV,\n    clipUV,\n    textureUV,\n    0,\n    -1,\n    vec4<f32>(layout, 0.0, 0.0),\n    vec4<f32>(0.0),\n    vec4<f32>(expand, 0.0, 0.0, 0.0),\n    vec4<f32>(0.0),\n    color,\n    instanceIndex,\n  );\n}",
  "@use-gpu/wgsl/instance/vertex/label": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ getViewResolution, worldToClip, getPerspectiveScale }; \n\n@optional @link fn getIndex(i: u32) -> u32 { return 0u; };\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(-1.0, -1.0, 1.0, 1.0); };\n@optional @link fn getUV(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n@optional @link fn getLayout(i: u32) -> vec2<f32> { return vec2<f32>(0.0, 0.0); };\n\n@optional @link fn getSDFConfig(i: u32) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 16.0, 0.0); };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getPlacement(i: u32) -> vec2<f32> { return vec2<f32>(0.0, 0.0); };\n@optional @link fn getOffset(i: u32) -> f32 { return 0.0; };\n@optional @link fn getSize(i: u32) -> f32 { return 16.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getExpand(i: u32) -> f32 { return 0.0; };\n@optional @link fn getFlip(i: u32) -> vec2<f32> { return vec2<f32>(1.0, 1.0); };\n\n@export fn getLabelVertex(vertexIndex: u32, instanceIndex: u32) -> UIVertex {\n\n  var sdfConfig = getSDFConfig(instanceIndex);\n  var fontSize = sdfConfig.z;\n\n  var index = getIndex(instanceIndex);\n  var rectangle = getRectangle(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n\n  var flip = getFlip(index);\n\n  var position = getPosition(index);\n  var placement = getPlacement(index) * flip;\n  var layout = getLayout(index);\n  var offset = getOffset(index);\n  var size = getSize(index);\n  var depth = getDepth(index);\n  var color = getColor(index);\n  var expand = getExpand(index);\n\n  var center = worldToClip(position);\n  \n  // Lay out quad\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  var origin = ((placement - 1.0) * 0.5 * layout) + (offset * placement);\n\n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n\n  // Factor in relative font and atlas scale\n  var glyphScale = size / fontSize;\n  var finalScale = pixelScale * glyphScale;\n\n  // Apply half pixel edge bleed on XY and UV\n  var xy: vec2<f32>;\n  var uv: vec2<f32>;\n  /*\n  if (HAS_EDGE_BLEED) {\n    let bleed = 0.5;\n    var ul = (rectangle.xy + origin) * finalScale - bleed;\n    var br = (rectangle.zw + origin) * finalScale + bleed;\n    var wh = (rectangle.zw - rectangle.xy) * finalScale;\n\n    xy = mix(ul, br, uv1);\n    uv = mix(uv4.xy, uv4.zw, uv1 + xy1 * bleed / wh);\n  }\n  else {\n  */\n    xy = mix(rectangle.xy + origin, rectangle.zw + origin, uv1) * finalScale;\n    uv = mix(uv4.xy, uv4.zw, uv1);\n  // }\n\n  xy = xy * flip;\n\n  // Attach to position\n  center = vec4<f32>(center.xy + 2.0 * xy * getViewResolution() * center.w, center.zw);\n  \n  let sdfUV = uv;\n  let textureUV = uv;\n  let clipUV = vec4<f32>(0.0, 0.0, 1.0, 1.0);\n\n  return UIVertex(\n    center,\n    uv1,\n    sdfConfig,\n    sdfUV,\n    clipUV,\n    textureUV,\n    0,\n    -1,\n    vec4<f32>(layout, 0.0, 0.0),\n    vec4<f32>(0.0),\n    vec4<f32>(expand, 0.0, 0.0, 0.0),\n    vec4<f32>(0.0),\n    color,\n    instanceIndex,\n  );\n}",
  "instance/vertex/line": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToView, viewToClip, toClip3D, clipLineIntoView, getPerspectiveScale, applyZBias3 };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\nuse '@use-gpu/wgsl/geometry/arrow'::{ getArrowSize };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getSegment(i: u32) -> i32 { return 0; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getWidth(i: u32) -> f32 { return 1.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getZBias(i: u32) -> f32 { return 0.0; };\n  \n@optional @link fn getTrim(i: u32) -> vec4<u32> { return vec4<u32>(0u, 0u, 0u, 0u); };\n@optional @link fn getSize(i: u32) -> f32 { return 3.0; };\n\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n\nlet ARROW_ASPECT: f32 = 2.5;\n\nfn getAnchorDistance(anchor: vec3<f32>, tangent: vec3<f32>, center: vec3<f32>) -> f32 {\n  var diff = center - anchor;\n\n  var distance = dot(diff, tangent);\n  var align = dot(normalize(diff), tangent);\n\n  if (length(diff) == 0.0) { return 0.0; }\n  else if (align > 0.92) { return distance; }\n  else { return -1.0; }\n}\n\nfn trimAnchor(\n  maxLength: f32,\n  anchor: vec3<f32>,\n  next: vec3<f32>,\n  center: vec3<f32>,\n  after: vec3<f32>,\n  width: f32,\n  size: f32,\n  both: i32,\n  w: f32,\n  depth: f32,\n) -> vec3<f32> {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var tangent = normalize(next - anchor);\n  var distanceStart = getAnchorDistance(anchor, tangent, center);\n  var distanceEnd = getAnchorDistance(anchor, tangent, after);\n\n  var arrowLength = getArrowSize(maxLength, width, size, both, w, depth) * ARROW_ASPECT;\n\n  if (distanceStart >= 0.0 && distanceStart < arrowLength) {\n    if (distanceEnd >= 0.0 && distanceEnd < arrowLength) {\n      return vec3<f32>(NaN, NaN, NaN);\n    }\n    else {\n      let ratio = (arrowLength - distanceStart) / (distanceEnd - distanceStart);\n      return mix(center, after, ratio);\n    }\n  }\n\n  return center;\n}\n\n@export fn getLineVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var ij = getStripIndex(vertexIndex);\n\n  var segmentLeft = getSegment(instanceIndex);\n  if (segmentLeft == 0 || segmentLeft == 2) {\n    return SolidVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN),\n      0u,\n    );\n  }\n\n  var uv = vec2<f32>(ij);\n  var xy = uv * 2.0 - 1.0;\n\n  var cornerIndex: u32;\n  var joinIndex: u32;\n  if (ij.x == 0u) {\n    joinIndex = u32(LINE_JOIN_SIZE);\n    cornerIndex = instanceIndex;\n  }\n  else {\n    joinIndex = ij.x - 1u;\n    cornerIndex = instanceIndex + 1u;\n  }\n\n  var trim = getTrim(instanceIndex);\n  var trimMode = i32(trim.z);\n\n  var segment = getSegment(cornerIndex);\n  var color = getColor(cornerIndex);\n  var width = getWidth(cornerIndex);\n  var depth = getDepth(cornerIndex);\n  var zBias = getZBias(cornerIndex);\n\n  var centerPos = getPosition(cornerIndex);\n  var beforePos = centerPos;\n  var afterPos = centerPos;\n\n  if (segment != 1) { beforePos = getPosition(cornerIndex - 1u); }\n  else { trimMode = trimMode & 1; }\n  if (segment != 2) { afterPos = getPosition(cornerIndex + 1u); }\n  else { trimMode = trimMode & 2; }\n\n  // Trim from end points\n  if (trimMode > 0) {\n    var size = getSize(cornerIndex);\n\n    var startIndex = trim.x;\n    var endIndex = trim.y;\n    var midIndex = (startIndex + endIndex) / 2u;\n\n    var startPos = getPosition(startIndex);\n    var midPos = getPosition(midIndex);\n    var endPos = getPosition(endIndex);\n\n    let maxLength = length(endPos.xyz - midPos.xyz) + length(midPos.xyz - startPos.xyz);\n\n    var both = 0;\n    if (trimMode == 3) { both = 1; }\n\n    if ((trimMode & 1) != 0) {\n      var start = worldToClip(startPos);\n      if (start.w > 0.0) {\n        var nextPos = getPosition(trim.x + 1u);\n        var trimmed = trimAnchor(maxLength, startPos.xyz, nextPos.xyz, centerPos.xyz, afterPos.xyz, width, size, both, start.w, depth);\n        centerPos = vec4<f32>(trimmed, 1.0);\n      }\n    }\n    if ((trimMode & 2) != 0) {\n      var end = worldToClip(endPos);\n      if (end.w > 0.0) {\n        var nextPos = getPosition(trim.y - 1u);\n        var trimmed = trimAnchor(maxLength, endPos.xyz, nextPos.xyz, centerPos.xyz, beforePos.xyz, width, size, both, end.w, depth);\n        centerPos = vec4<f32>(trimmed, 1.0);\n      }\n    }\n  }\n\n  // Clip ends into view\n  var clipBeforeV = clipLineIntoView(beforePos, centerPos);\n  var clipAfterV  = clipLineIntoView(afterPos, centerPos);\n\n  var before = toClip3D(viewToClip(clipBeforeV));\n  var after  = toClip3D(viewToClip(clipAfterV));\n\n  var centerV = worldToView(centerPos);\n  var center4 = viewToClip(centerV);\n\n  if (center4.w <= 0.0) {\n    if (ij.x == 0u) {\n      centerV = clipLineIntoView(centerPos, afterPos);\n    }\n    else if (ij.x != 0u) {\n      centerV = clipLineIntoView(centerPos, beforePos);\n    }\n    else {\n      return SolidVertex(\n        vec4(NaN, NaN, NaN, NaN),\n        vec4(NaN, NaN, NaN, NaN),\n        vec2(NaN, NaN),\n        instanceIndex,\n      );\n    }\n    center4 = viewToClip(centerV);\n  }\n\n  var center = toClip3D(center4);\n\n  // Lerp between fixed size and full perspective\n  var pixelScale = getPerspectiveScale(center4.w, depth);\n  width = width * pixelScale;\n\n  var arc = f32(joinIndex) / f32(LINE_JOIN_SIZE);\n  var lineJoin = getLineJoin(before, center, after, arc, xy.y, width, segment, LINE_JOIN_STYLE);\n\n  if (zBias != 0.0) {\n    lineJoin = applyZBias3(lineJoin, width * zBias, center4.w);\n  }\n\n  return SolidVertex(\n    vec4<f32>(lineJoin, 1.0) * center4.w,\n    color,\n    uv,\n    getLookup(cornerIndex),\n  );\n}\n",
  "@use-gpu/wgsl/instance/vertex/line": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToView, viewToClip, toClip3D, clipLineIntoView, getPerspectiveScale, applyZBias3 };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\nuse '@use-gpu/wgsl/geometry/arrow'::{ getArrowSize };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getSegment(i: u32) -> i32 { return 0; };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getWidth(i: u32) -> f32 { return 1.0; };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getZBias(i: u32) -> f32 { return 0.0; };\n  \n@optional @link fn getTrim(i: u32) -> vec4<u32> { return vec4<u32>(0u, 0u, 0u, 0u); };\n@optional @link fn getSize(i: u32) -> f32 { return 3.0; };\n\n@optional @link fn getLookup(i: u32) -> u32 { return i; };\n\nlet ARROW_ASPECT: f32 = 2.5;\n\nfn getAnchorDistance(anchor: vec3<f32>, tangent: vec3<f32>, center: vec3<f32>) -> f32 {\n  var diff = center - anchor;\n\n  var distance = dot(diff, tangent);\n  var align = dot(normalize(diff), tangent);\n\n  if (length(diff) == 0.0) { return 0.0; }\n  else if (align > 0.92) { return distance; }\n  else { return -1.0; }\n}\n\nfn trimAnchor(\n  maxLength: f32,\n  anchor: vec3<f32>,\n  next: vec3<f32>,\n  center: vec3<f32>,\n  after: vec3<f32>,\n  width: f32,\n  size: f32,\n  both: i32,\n  w: f32,\n  depth: f32,\n) -> vec3<f32> {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var tangent = normalize(next - anchor);\n  var distanceStart = getAnchorDistance(anchor, tangent, center);\n  var distanceEnd = getAnchorDistance(anchor, tangent, after);\n\n  var arrowLength = getArrowSize(maxLength, width, size, both, w, depth) * ARROW_ASPECT;\n\n  if (distanceStart >= 0.0 && distanceStart < arrowLength) {\n    if (distanceEnd >= 0.0 && distanceEnd < arrowLength) {\n      return vec3<f32>(NaN, NaN, NaN);\n    }\n    else {\n      let ratio = (arrowLength - distanceStart) / (distanceEnd - distanceStart);\n      return mix(center, after, ratio);\n    }\n  }\n\n  return center;\n}\n\n@export fn getLineVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var ij = getStripIndex(vertexIndex);\n\n  var segmentLeft = getSegment(instanceIndex);\n  if (segmentLeft == 0 || segmentLeft == 2) {\n    return SolidVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN),\n      0u,\n    );\n  }\n\n  var uv = vec2<f32>(ij);\n  var xy = uv * 2.0 - 1.0;\n\n  var cornerIndex: u32;\n  var joinIndex: u32;\n  if (ij.x == 0u) {\n    joinIndex = u32(LINE_JOIN_SIZE);\n    cornerIndex = instanceIndex;\n  }\n  else {\n    joinIndex = ij.x - 1u;\n    cornerIndex = instanceIndex + 1u;\n  }\n\n  var trim = getTrim(instanceIndex);\n  var trimMode = i32(trim.z);\n\n  var segment = getSegment(cornerIndex);\n  var color = getColor(cornerIndex);\n  var width = getWidth(cornerIndex);\n  var depth = getDepth(cornerIndex);\n  var zBias = getZBias(cornerIndex);\n\n  var centerPos = getPosition(cornerIndex);\n  var beforePos = centerPos;\n  var afterPos = centerPos;\n\n  if (segment != 1) { beforePos = getPosition(cornerIndex - 1u); }\n  else { trimMode = trimMode & 1; }\n  if (segment != 2) { afterPos = getPosition(cornerIndex + 1u); }\n  else { trimMode = trimMode & 2; }\n\n  // Trim from end points\n  if (trimMode > 0) {\n    var size = getSize(cornerIndex);\n\n    var startIndex = trim.x;\n    var endIndex = trim.y;\n    var midIndex = (startIndex + endIndex) / 2u;\n\n    var startPos = getPosition(startIndex);\n    var midPos = getPosition(midIndex);\n    var endPos = getPosition(endIndex);\n\n    let maxLength = length(endPos.xyz - midPos.xyz) + length(midPos.xyz - startPos.xyz);\n\n    var both = 0;\n    if (trimMode == 3) { both = 1; }\n\n    if ((trimMode & 1) != 0) {\n      var start = worldToClip(startPos);\n      if (start.w > 0.0) {\n        var nextPos = getPosition(trim.x + 1u);\n        var trimmed = trimAnchor(maxLength, startPos.xyz, nextPos.xyz, centerPos.xyz, afterPos.xyz, width, size, both, start.w, depth);\n        centerPos = vec4<f32>(trimmed, 1.0);\n      }\n    }\n    if ((trimMode & 2) != 0) {\n      var end = worldToClip(endPos);\n      if (end.w > 0.0) {\n        var nextPos = getPosition(trim.y - 1u);\n        var trimmed = trimAnchor(maxLength, endPos.xyz, nextPos.xyz, centerPos.xyz, beforePos.xyz, width, size, both, end.w, depth);\n        centerPos = vec4<f32>(trimmed, 1.0);\n      }\n    }\n  }\n\n  // Clip ends into view\n  var clipBeforeV = clipLineIntoView(beforePos, centerPos);\n  var clipAfterV  = clipLineIntoView(afterPos, centerPos);\n\n  var before = toClip3D(viewToClip(clipBeforeV));\n  var after  = toClip3D(viewToClip(clipAfterV));\n\n  var centerV = worldToView(centerPos);\n  var center4 = viewToClip(centerV);\n\n  if (center4.w <= 0.0) {\n    if (ij.x == 0u) {\n      centerV = clipLineIntoView(centerPos, afterPos);\n    }\n    else if (ij.x != 0u) {\n      centerV = clipLineIntoView(centerPos, beforePos);\n    }\n    else {\n      return SolidVertex(\n        vec4(NaN, NaN, NaN, NaN),\n        vec4(NaN, NaN, NaN, NaN),\n        vec2(NaN, NaN),\n        instanceIndex,\n      );\n    }\n    center4 = viewToClip(centerV);\n  }\n\n  var center = toClip3D(center4);\n\n  // Lerp between fixed size and full perspective\n  var pixelScale = getPerspectiveScale(center4.w, depth);\n  width = width * pixelScale;\n\n  var arc = f32(joinIndex) / f32(LINE_JOIN_SIZE);\n  var lineJoin = getLineJoin(before, center, after, arc, xy.y, width, segment, LINE_JOIN_STYLE);\n\n  if (zBias != 0.0) {\n    lineJoin = applyZBias3(lineJoin, width * zBias, center4.w);\n  }\n\n  return SolidVertex(\n    vec4<f32>(lineJoin, 1.0) * center4.w,\n    color,\n    uv,\n    getLookup(cornerIndex),\n  );\n}\n",
  "instance/vertex/quad": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ getViewResolution, worldToClip, getPerspectiveScale, getViewScale, applyZBias }; \nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(-1.0, -1.0, 1.0, 1.0); };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getZBias(i: u32) -> f32 { return 0.0; };\n@optional @link fn getUV(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n\n@export fn getQuadVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var position = getPosition(instanceIndex);\n  var rectangle = getRectangle(instanceIndex);\n  var color = getColor(instanceIndex);\n  var depth = getDepth(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n  var zBias = getZBias(instanceIndex);\n\n  var center = worldToClip(position);\n\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  \n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n\n  // Apply half pixel edge bleed on XY and UV\n  var xy: vec2<f32>;\n  var uv: vec2<f32>;\n  if (HAS_EDGE_BLEED) {\n    let bleed = 0.5;\n    var ul = rectangle.xy * pixelScale - bleed;\n    var br = rectangle.zw * pixelScale + bleed;\n    var wh = (rectangle.zw - rectangle.xy) * pixelScale;\n\n    xy = mix(ul, br, uv1);\n    uv = mix(uv4.xy, uv4.zw, uv1 + xy1 * bleed / wh);\n  }\n  else {\n    xy = mix(rectangle.xy, rectangle.zw, uv1) * pixelScale;\n    uv = mix(uv4.xy, uv4.zw, uv1);\n  }\n\n  // Attach to position\n  var vr = getViewResolution();\n  var offset = xy * vr;\n  center = vec4<f32>(center.xy + 2.0 * offset * center.w, center.zw);\n\n  if (zBias != 0.0) {\n    var size = max(xy.x, xy.y) * vr.y;\n    center = applyZBias(center, size * zBias);\n  }\n\n  return SolidVertex(\n    center,\n    color,\n    uv,\n    instanceIndex,\n  );\n}",
  "@use-gpu/wgsl/instance/vertex/quad": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ getViewResolution, worldToClip, getPerspectiveScale, getViewScale, applyZBias }; \nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\n@optional @link fn getPosition(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 1.0); };\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(-1.0, -1.0, 1.0, 1.0); };\n@optional @link fn getColor(i: u32) -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); };\n@optional @link fn getDepth(i: u32) -> f32 { return 0.0; };\n@optional @link fn getZBias(i: u32) -> f32 { return 0.0; };\n@optional @link fn getUV(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); };\n\n@export fn getQuadVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var position = getPosition(instanceIndex);\n  var rectangle = getRectangle(instanceIndex);\n  var color = getColor(instanceIndex);\n  var depth = getDepth(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n  var zBias = getZBias(instanceIndex);\n\n  var center = worldToClip(position);\n\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  \n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n\n  // Apply half pixel edge bleed on XY and UV\n  var xy: vec2<f32>;\n  var uv: vec2<f32>;\n  if (HAS_EDGE_BLEED) {\n    let bleed = 0.5;\n    var ul = rectangle.xy * pixelScale - bleed;\n    var br = rectangle.zw * pixelScale + bleed;\n    var wh = (rectangle.zw - rectangle.xy) * pixelScale;\n\n    xy = mix(ul, br, uv1);\n    uv = mix(uv4.xy, uv4.zw, uv1 + xy1 * bleed / wh);\n  }\n  else {\n    xy = mix(rectangle.xy, rectangle.zw, uv1) * pixelScale;\n    uv = mix(uv4.xy, uv4.zw, uv1);\n  }\n\n  // Attach to position\n  var vr = getViewResolution();\n  var offset = xy * vr;\n  center = vec4<f32>(center.xy + 2.0 * offset * center.w, center.zw);\n\n  if (zBias != 0.0) {\n    var size = max(xy.x, xy.y) * vr.y;\n    center = applyZBias(center, size * zBias);\n  }\n\n  return SolidVertex(\n    center,\n    color,\n    uv,\n    instanceIndex,\n  );\n}",
  "instance/vertex/tick": "use '@use-gpu/wgsl/use/view'::{ worldToClip, getWorldScale, getViewScale };\n\n@link fn transformPosition(p: vec4<f32>) -> vec4<f32>;\n\n@link fn getPosition(i: u32) -> vec4<f32>;\n@link fn getOffset(i: u32) -> vec4<f32>;\n@link fn getDepth(i: u32) -> f32;\n@link fn getSize(i: u32) -> f32;\n\n@optional @link fn getTangent(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn getBase(i: u32) -> f32 { return 2.0; }\n\nlet EPSILON: f32 = 0.001;\n\n@export fn getTickPosition(index: u32) -> vec4<f32> {\n  let n = u32(LINE_DETAIL + 1);\n  let v = f32(index % n) / f32(LINE_DETAIL) - 0.5;\n\n  let instanceIndex = index / n;\n\n  let anchor = getPosition(instanceIndex);\n  let offset = getOffset(instanceIndex);\n  let depth = getDepth(instanceIndex);\n  let size = getSize(instanceIndex);\n  let tangent = getTangent(instanceIndex);\n  let base = getBase(instanceIndex);\n\n  let center = transformPosition(anchor);\n  let c = worldToClip(center);\n  let s = getWorldScale(c.w, depth) * getViewScale();\n\n  if (length(tangent) > 0.0) {\n    let adj = transformPosition(anchor + tangent * EPSILON);\n    let diff = (adj.xyz - center.xyz) / EPSILON;\n\n    let l = length(diff) * 0.999;\n    let limit = s * size;\n    let trunc = limit / l;\n\n    let modulus = u32(round(pow(base, ceil(log(trunc)/log(base)))));\n    if ((modulus > 1u) && ((instanceIndex % modulus) != 0u)) {\n      var NaN: f32 = bitcast<f32>(0xffffffffu);\n      return vec4<f32>(NaN, NaN, NaN, NaN);\n    }\n  }\n\n  let adj = transformPosition(anchor + offset * EPSILON);\n  let normal = normalize(adj.xyz - center.xyz);\n  \n  return center + vec4<f32>(normal * size * v * s, 0.0);\n}\n",
  "@use-gpu/wgsl/instance/vertex/tick": "use '@use-gpu/wgsl/use/view'::{ worldToClip, getWorldScale, getViewScale };\n\n@link fn transformPosition(p: vec4<f32>) -> vec4<f32>;\n\n@link fn getPosition(i: u32) -> vec4<f32>;\n@link fn getOffset(i: u32) -> vec4<f32>;\n@link fn getDepth(i: u32) -> f32;\n@link fn getSize(i: u32) -> f32;\n\n@optional @link fn getTangent(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn getBase(i: u32) -> f32 { return 2.0; }\n\nlet EPSILON: f32 = 0.001;\n\n@export fn getTickPosition(index: u32) -> vec4<f32> {\n  let n = u32(LINE_DETAIL + 1);\n  let v = f32(index % n) / f32(LINE_DETAIL) - 0.5;\n\n  let instanceIndex = index / n;\n\n  let anchor = getPosition(instanceIndex);\n  let offset = getOffset(instanceIndex);\n  let depth = getDepth(instanceIndex);\n  let size = getSize(instanceIndex);\n  let tangent = getTangent(instanceIndex);\n  let base = getBase(instanceIndex);\n\n  let center = transformPosition(anchor);\n  let c = worldToClip(center);\n  let s = getWorldScale(c.w, depth) * getViewScale();\n\n  if (length(tangent) > 0.0) {\n    let adj = transformPosition(anchor + tangent * EPSILON);\n    let diff = (adj.xyz - center.xyz) / EPSILON;\n\n    let l = length(diff) * 0.999;\n    let limit = s * size;\n    let trunc = limit / l;\n\n    let modulus = u32(round(pow(base, ceil(log(trunc)/log(base)))));\n    if ((modulus > 1u) && ((instanceIndex % modulus) != 0u)) {\n      var NaN: f32 = bitcast<f32>(0xffffffffu);\n      return vec4<f32>(NaN, NaN, NaN, NaN);\n    }\n  }\n\n  let adj = transformPosition(anchor + offset * EPSILON);\n  let normal = normalize(adj.xyz - center.xyz);\n  \n  return center + vec4<f32>(normal * size * v * s, 0.0);\n}\n",
  "instance/vertex/ui-rectangle": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D, toClip3D, getViewResolution, getViewSize }; \n\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getRadius(i: u32)    -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getBorder(i: u32)    -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getStroke(i: u32)    -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); }\n@optional @link fn getFill(i: u32)      -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); }\n@optional @link fn getUV(i: u32)        -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); }\n@optional @link fn getRepeat(i: u32)    -> i32       { return 0; }\n\n@optional @link fn getSDFConfig(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn applyTransform(p: vec4<f32>) -> vec4<f32> { return p; }\n@optional @link fn getClip(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\n@export fn getUIRectangleVertex(vertexIndex: u32, instanceIndex: u32) -> UIVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  // Layout clipping for overflow\n  var rectangle = getRectangle(instanceIndex);\n  var clip = getClip(instanceIndex);\n\n  var clipUV = vec4<f32>(-1.0, -1.0, 2.0, 2.0);\n  if (length(clip) > 0.0) {\n    if (\n      rectangle.z < clip.x || rectangle.w < clip.y ||\n      rectangle.x > clip.z || rectangle.y > clip.w\n    ) {\n      return UIVertex(\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        0,\n        0,\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        0u,\n      );\n    }\n    \n    if (rectangle.x < clip.x) {\n      clipUV.x = (clip.x - rectangle.x) / (rectangle.z - rectangle.x);\n    }\n    if (rectangle.z > clip.z) {\n      clipUV.z = (clip.z - rectangle.x) / (rectangle.z - rectangle.x);\n    }\n    if (rectangle.y < clip.y) {\n      clipUV.y = (clip.y - rectangle.y) / (rectangle.w - rectangle.y);\n    }\n    if (rectangle.w > clip.w) {\n      clipUV.w = (clip.w - rectangle.y) / (rectangle.w - rectangle.y);\n    }\n  }\n\n  var radius = getRadius(instanceIndex);\n  var border = getBorder(instanceIndex);\n  var fill = getFill(instanceIndex);\n  var stroke = getStroke(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n  var repeat = getRepeat(instanceIndex);\n  var sdfConfig = getSDFConfig(instanceIndex);\n\n  // Fragment shader mode\n  var mode: i32;\n  if (sdfConfig.x > 0.0) {\n    // SDF glyph\n    if (uv4.z < 0.0) { mode = -2; }\n    else { mode = -1; }\n    uv4 = abs(uv4);\n  }\n  else if (length(radius + border) == 0.0) { mode = 0; } // Rectangle\n  else if (length(radius) == 0.0) { mode = 1; } // Rectangle with border\n  else { mode = 2; }; // Rounded rectangle with border\n\n  // Prepare quad -> pixel mapping\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  let box = rectangle.zw - rectangle.xy;\n\n  // Get corner + two adjacent vertices\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv1), 0.0, 1.0);\n  var posFlipX = vec4<f32>(mix(rectangle.xy, rectangle.zw, vec2<f32>(1.0 - uv1.x, uv1.y)), 0.0, 1.0);\n  var posFlipY = vec4<f32>(mix(rectangle.xy, rectangle.zw, vec2<f32>(uv1.x, 1.0 - uv1.y)), 0.0, 1.0);\n\n  var center4  = worldToClip(applyTransform(position));\n\n  var center  = toClip3D(center4);\n  var centerX = worldToClip3D(applyTransform(posFlipX));\n  var centerY = worldToClip3D(applyTransform(posFlipY));\n\n  // Get side length in screen pixels\n  var size = getViewSize();\n  var dx = (center.xy - centerX.xy) * size;\n  var dy = (center.xy - centerY.xy) * size;\n\n  var stepX = normalize(dx);\n  var stepY = normalize(dy);\n\n  var sdfUV: vec2<f32>;\n  var conservative: vec3<f32>;\n  if (mode == -1 || mode == -2) {\n    // Rasterize glyphs normally (they are pre-padded)\n    conservative = center;\n    sdfUV = uv1 * (uv4.zw - uv4.xy);\n  }\n  else {\n    // Rasterize shapes conservatively\n    conservative = vec3<f32>(center.xy + (stepX + stepY) * getViewResolution(), center.z);\n    uv1 = uv1 + xy1 / vec2<f32>(length(dx), length(dy));\n    sdfUV = uv1 * box;\n  }\n\n  var uv = mix(uv4.xy, uv4.zw, uv1);\n  let textureUV = uv;\n  \n  return UIVertex(\n    vec4<f32>(conservative, 1.0) * center4.w,\n    uv1,\n    sdfConfig,\n    sdfUV,\n    clipUV,\n    textureUV,\n    repeat,\n    mode,\n    vec4<f32>(box, 0.0, 0.0),\n    radius,\n    border,\n    stroke,\n    fill,\n    instanceIndex,\n  );\n}\n",
  "@use-gpu/wgsl/instance/vertex/ui-rectangle": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D, toClip3D, getViewResolution, getViewSize }; \n\n@optional @link fn getRectangle(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getRadius(i: u32)    -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getBorder(i: u32)    -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n@optional @link fn getStroke(i: u32)    -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); }\n@optional @link fn getFill(i: u32)      -> vec4<f32> { return vec4<f32>(0.5, 0.5, 0.5, 1.0); }\n@optional @link fn getUV(i: u32)        -> vec4<f32> { return vec4<f32>(0.0, 0.0, 1.0, 1.0); }\n@optional @link fn getRepeat(i: u32)    -> i32       { return 0; }\n\n@optional @link fn getSDFConfig(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); };\n@optional @link fn applyTransform(p: vec4<f32>) -> vec4<f32> { return p; }\n@optional @link fn getClip(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\n@export fn getUIRectangleVertex(vertexIndex: u32, instanceIndex: u32) -> UIVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  // Layout clipping for overflow\n  var rectangle = getRectangle(instanceIndex);\n  var clip = getClip(instanceIndex);\n\n  var clipUV = vec4<f32>(-1.0, -1.0, 2.0, 2.0);\n  if (length(clip) > 0.0) {\n    if (\n      rectangle.z < clip.x || rectangle.w < clip.y ||\n      rectangle.x > clip.z || rectangle.y > clip.w\n    ) {\n      return UIVertex(\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec2<f32>(NaN, NaN),\n        0,\n        0,\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        vec4<f32>(NaN, NaN, NaN, NaN),\n        0u,\n      );\n    }\n    \n    if (rectangle.x < clip.x) {\n      clipUV.x = (clip.x - rectangle.x) / (rectangle.z - rectangle.x);\n    }\n    if (rectangle.z > clip.z) {\n      clipUV.z = (clip.z - rectangle.x) / (rectangle.z - rectangle.x);\n    }\n    if (rectangle.y < clip.y) {\n      clipUV.y = (clip.y - rectangle.y) / (rectangle.w - rectangle.y);\n    }\n    if (rectangle.w > clip.w) {\n      clipUV.w = (clip.w - rectangle.y) / (rectangle.w - rectangle.y);\n    }\n  }\n\n  var radius = getRadius(instanceIndex);\n  var border = getBorder(instanceIndex);\n  var fill = getFill(instanceIndex);\n  var stroke = getStroke(instanceIndex);\n  var uv4 = getUV(instanceIndex);\n  var repeat = getRepeat(instanceIndex);\n  var sdfConfig = getSDFConfig(instanceIndex);\n\n  // Fragment shader mode\n  var mode: i32;\n  if (sdfConfig.x > 0.0) {\n    // SDF glyph\n    if (uv4.z < 0.0) { mode = -2; }\n    else { mode = -1; }\n    uv4 = abs(uv4);\n  }\n  else if (length(radius + border) == 0.0) { mode = 0; } // Rectangle\n  else if (length(radius) == 0.0) { mode = 1; } // Rectangle with border\n  else { mode = 2; }; // Rounded rectangle with border\n\n  // Prepare quad -> pixel mapping\n  var uv1 = getQuadUV(vertexIndex);\n  var xy1 = uv1 * 2.0 - 1.0;\n  let box = rectangle.zw - rectangle.xy;\n\n  // Get corner + two adjacent vertices\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv1), 0.0, 1.0);\n  var posFlipX = vec4<f32>(mix(rectangle.xy, rectangle.zw, vec2<f32>(1.0 - uv1.x, uv1.y)), 0.0, 1.0);\n  var posFlipY = vec4<f32>(mix(rectangle.xy, rectangle.zw, vec2<f32>(uv1.x, 1.0 - uv1.y)), 0.0, 1.0);\n\n  var center4  = worldToClip(applyTransform(position));\n\n  var center  = toClip3D(center4);\n  var centerX = worldToClip3D(applyTransform(posFlipX));\n  var centerY = worldToClip3D(applyTransform(posFlipY));\n\n  // Get side length in screen pixels\n  var size = getViewSize();\n  var dx = (center.xy - centerX.xy) * size;\n  var dy = (center.xy - centerY.xy) * size;\n\n  var stepX = normalize(dx);\n  var stepY = normalize(dy);\n\n  var sdfUV: vec2<f32>;\n  var conservative: vec3<f32>;\n  if (mode == -1 || mode == -2) {\n    // Rasterize glyphs normally (they are pre-padded)\n    conservative = center;\n    sdfUV = uv1 * (uv4.zw - uv4.xy);\n  }\n  else {\n    // Rasterize shapes conservatively\n    conservative = vec3<f32>(center.xy + (stepX + stepY) * getViewResolution(), center.z);\n    uv1 = uv1 + xy1 / vec2<f32>(length(dx), length(dy));\n    sdfUV = uv1 * box;\n  }\n\n  var uv = mix(uv4.xy, uv4.zw, uv1);\n  let textureUV = uv;\n  \n  return UIVertex(\n    vec4<f32>(conservative, 1.0) * center4.w,\n    uv1,\n    sdfConfig,\n    sdfUV,\n    clipUV,\n    textureUV,\n    repeat,\n    mode,\n    vec4<f32>(box, 0.0, 0.0),\n    radius,\n    border,\n    stroke,\n    fill,\n    instanceIndex,\n  );\n}\n",
  "layout/clip": "@optional @link fn applyTransform(p: vec4<f32>) -> vec4<f32> { return p; }\n\n@link fn getParent(i: u32) -> {}\n@optional @link fn getSelf(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\n@export fn getCombinedClip(i: u32) -> vec4<f32> {\n  let a = transformClip(getParent(i));\n  let b = getSelf(i);\n  return intersectClips(a, b);\n}\n\n@export fn getTransformedClip(i: u32) -> vec4<f32> {\n  return transformClip(getParent(i));\n}\n\nfn transformClip(rect: vec4<f32>) -> vec4<f32> {\n  let ul = applyTransform(vec4<f32>(rect.xy, 0.5, 1.0));\n  let br = applyTransform(vec4<f32>(rect.zw, 0.5, 1.0));\n\n  return vec4<f32>(ul.xy, br.xy);\n}\n\nfn intersectClips(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n",
  "@use-gpu/wgsl/layout/clip": "@optional @link fn applyTransform(p: vec4<f32>) -> vec4<f32> { return p; }\n\n@link fn getParent(i: u32) -> {}\n@optional @link fn getSelf(i: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\n@export fn getCombinedClip(i: u32) -> vec4<f32> {\n  let a = transformClip(getParent(i));\n  let b = getSelf(i);\n  return intersectClips(a, b);\n}\n\n@export fn getTransformedClip(i: u32) -> vec4<f32> {\n  return transformClip(getParent(i));\n}\n\nfn transformClip(rect: vec4<f32>) -> vec4<f32> {\n  let ul = applyTransform(vec4<f32>(rect.xy, 0.5, 1.0));\n  let br = applyTransform(vec4<f32>(rect.zw, 0.5, 1.0));\n\n  return vec4<f32>(ul.xy, br.xy);\n}\n\nfn intersectClips(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(max(a.xy, b.xy), min(a.zw, b.zw));\n}\n",
  "layout/layout": "@link fn getFlip(i: u32) -> vec2<f32>;\n@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getLayoutPosition(position: vec4<f32>) -> vec4<f32> {\n  let flip = getFlip(0u);\n  let offset = getOffset(0u);\n\n  var x = position.x;\n  var y = position.y;\n  if (flip.x > 0.0) { x = flip.x - x; }\n  if (flip.y > 0.0) { y = flip.y - y; }\n  return vec4<f32>(vec2<f32>(x, y) + offset, position.zw);\n}\n",
  "@use-gpu/wgsl/layout/layout": "@link fn getFlip(i: u32) -> vec2<f32>;\n@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getLayoutPosition(position: vec4<f32>) -> vec4<f32> {\n  let flip = getFlip(0u);\n  let offset = getOffset(0u);\n\n  var x = position.x;\n  var y = position.y;\n  if (flip.x > 0.0) { x = flip.x - x; }\n  if (flip.y > 0.0) { y = flip.y - y; }\n  return vec4<f32>(vec2<f32>(x, y) + offset, position.zw);\n}\n",
  "layout/scroll": "@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getScrolledPosition(position: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(position.xy + getOffset(0u), position.zw);\n}\n",
  "@use-gpu/wgsl/layout/scroll": "@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getScrolledPosition(position: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(position.xy + getOffset(0u), position.zw);\n}\n",
  "layout/shift": "@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getShiftedRectangle(rectangle: vec4<f32>) -> vec4<f32> {\n  let offset = getOffset(0u);\n  return vec4<f32>(rectangle.xy + offset, rectangle.zw + offset);\n}\n",
  "@use-gpu/wgsl/layout/shift": "@link fn getOffset(i: u32) -> vec2<f32>;\n\n@export fn getShiftedRectangle(rectangle: vec4<f32>) -> vec4<f32> {\n  let offset = getOffset(0u);\n  return vec4<f32>(rectangle.xy + offset, rectangle.zw + offset);\n}\n",
  "mask/masked": "@optional @link fn getMask(uv: vec2<f32>) -> f32 { return 1.0; };\n@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); };\n\n@export fn getMaskedFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  let t = getTexture(uv);\n  let m = getMask(uv);\n\n  var c = color;\n  \n  if (HAS_ALPHA_TO_COVERAGE) {\n    c = vec4<f32>(c.xyz * t.xyz, c.a * m * t.a);\n  }\n  else {\n    c = c * t * clamp(m, 0.0, 1.0);\n  }\n\n  return c;\n}\n",
  "@use-gpu/wgsl/mask/masked": "@optional @link fn getMask(uv: vec2<f32>) -> f32 { return 1.0; };\n@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); };\n\n@export fn getMaskedFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  let t = getTexture(uv);\n  let m = getMask(uv);\n\n  var c = color;\n  \n  if (HAS_ALPHA_TO_COVERAGE) {\n    c = vec4<f32>(c.xyz * t.xyz, c.a * m * t.a);\n  }\n  else {\n    c = c * t * clamp(m, 0.0, 1.0);\n  }\n\n  return c;\n}\n",
  "mask/passthru": "@export fn getPassThruFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return vec4<f32>(color.xyz * color.a, color.a);\n}\n",
  "@use-gpu/wgsl/mask/passthru": "@export fn getPassThruFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return vec4<f32>(color.xyz * color.a, color.a);\n}\n",
  "mask/point": "let OUTLINE = 0.4;\n\nfn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  // implicit * 2 / 2\n  return (length(dx) + length(dy));\n}\n\nfn scaleSDF(sdf: f32, scale: f32) -> f32 {\n  var d = sdf / scale + 0.5;\n  return clamp(d, 0.0, 1.0) * max(0.0, min(1.0, 2.0 / scale) * 2.0 - 1.0);\n}\n\nfn outlineSDF(sdf: f32) -> f32 {\n  return min(sdf, OUTLINE - sdf);\n}\n\nfn circleSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - length(xy);\n}\n\nfn diamondSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - (abs(xy.x) + abs(xy.y));\n}\n\nfn squareSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - max(abs(xy.x), abs(xy.y));\n}\n\n@export fn circle(uv: vec2<f32>) -> f32 {\n  var l = circleSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamond(uv: vec2<f32>) -> f32 {\n  var l = diamondSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn square(uv: vec2<f32>) -> f32 {\n  var l = squareSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn circleOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(circleSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamondOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(diamondSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn squareOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(squareSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n",
  "@use-gpu/wgsl/mask/point": "let OUTLINE = 0.4;\n\nfn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  // implicit * 2 / 2\n  return (length(dx) + length(dy));\n}\n\nfn scaleSDF(sdf: f32, scale: f32) -> f32 {\n  var d = sdf / scale + 0.5;\n  return clamp(d, 0.0, 1.0) * max(0.0, min(1.0, 2.0 / scale) * 2.0 - 1.0);\n}\n\nfn outlineSDF(sdf: f32) -> f32 {\n  return min(sdf, OUTLINE - sdf);\n}\n\nfn circleSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - length(xy);\n}\n\nfn diamondSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - (abs(xy.x) + abs(xy.y));\n}\n\nfn squareSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - max(abs(xy.x), abs(xy.y));\n}\n\n@export fn circle(uv: vec2<f32>) -> f32 {\n  var l = circleSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamond(uv: vec2<f32>) -> f32 {\n  var l = diamondSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn square(uv: vec2<f32>) -> f32 {\n  var l = squareSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn circleOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(circleSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamondOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(diamondSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn squareOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(squareSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n",
  "mask/textured": "@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); };\n\n@export fn getTextureFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return color * getTexture(uv);\n}\n",
  "@use-gpu/wgsl/mask/textured": "@optional @link fn getTexture(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); };\n\n@export fn getTextureFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return color * getTexture(uv);\n}\n",
  "material/pbr": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\n\n@optional @link fn getAlbedo(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); }\n@optional @link fn getMetalness(uv: vec2<f32>) -> f32 { return 0.2; }\n@optional @link fn getRoughness(uv: vec2<f32>) -> f32 { return 0.8; }\n\n@optional @link fn getMetalnessRoughness(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0); }\n\n@export fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  var albedo: vec3<f32> = materialColor.rgb * getAlbedo(mapUV).rgb;\n  \n  var metalnessRoughness: vec4<f32> = getMetalnessRoughness(mapUV);\n  var roughness: f32 = getRoughness(mapUV) * metalnessRoughness.g;\n  var metalness: f32 = getMetalness(mapUV) * metalnessRoughness.b;\n\n  return PBR(N, L, V, albedo, metalness, roughness) * lightColor.rgb;\n}\n",
  "@use-gpu/wgsl/material/pbr": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\n\n@optional @link fn getAlbedo(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0, 1.0, 1.0, 1.0); }\n@optional @link fn getMetalness(uv: vec2<f32>) -> f32 { return 0.2; }\n@optional @link fn getRoughness(uv: vec2<f32>) -> f32 { return 0.8; }\n\n@optional @link fn getMetalnessRoughness(uv: vec2<f32>) -> vec4<f32> { return vec4<f32>(1.0); }\n\n@export fn applyPBRMaterial(\n  materialColor: vec4<f32>,\n  lightColor: vec4<f32>,\n  mapUV: vec2<f32>,\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n) -> vec3<f32> {\n  var albedo: vec3<f32> = materialColor.rgb * getAlbedo(mapUV).rgb;\n  \n  var metalnessRoughness: vec4<f32> = getMetalnessRoughness(mapUV);\n  var roughness: f32 = getRoughness(mapUV) * metalnessRoughness.g;\n  var metalness: f32 = getMetalness(mapUV) * metalnessRoughness.b;\n\n  return PBR(N, L, V, albedo, metalness, roughness) * lightColor.rgb;\n}\n",
  "plot/array": "@link fn getSize(i: u32) -> vec4<u32> {};\n\n@export fn unpackIndex(i: u32) -> vec4<u32> {\n  let s = getSize(0u);\n  \n  let sxy = s.x * s.y;\n  let sxyz = sxy * s.z;\n  let modulus = vec4<u32>(s.x, sxy, sxyz, sxyz * s.w);\n\n  return (i % modulus) / vec4<u32>(1u, modulus.xyz);\n}\n\n@export fn packIndex(v: vec4<u32>) -> u32 {\n  let s = getSize(0u);\n  return v.x + s.x * (v.y + s.y * (v.z + s.z * v.w));\n}\n",
  "@use-gpu/wgsl/plot/array": "@link fn getSize(i: u32) -> vec4<u32> {};\n\n@export fn unpackIndex(i: u32) -> vec4<u32> {\n  let s = getSize(0u);\n  \n  let sxy = s.x * s.y;\n  let sxyz = sxy * s.z;\n  let modulus = vec4<u32>(s.x, sxy, sxyz, sxyz * s.w);\n\n  return (i % modulus) / vec4<u32>(1u, modulus.xyz);\n}\n\n@export fn packIndex(v: vec4<u32>) -> u32 {\n  let s = getSize(0u);\n  return v.x + s.x * (v.y + s.y * (v.z + s.z * v.w));\n}\n",
  "plot/axis": "@link fn getAxisStep(i: u32) -> vec4<f32>;\n@link fn getAxisOrigin(i: u32) -> vec4<f32>;\n\n@export fn getAxisPosition(index: u32) -> vec4<f32> {\n  return getAxisStep(0u) * f32(index) + getAxisOrigin(0u);\n}\n",
  "@use-gpu/wgsl/plot/axis": "@link fn getAxisStep(i: u32) -> vec4<f32>;\n@link fn getAxisOrigin(i: u32) -> vec4<f32>;\n\n@export fn getAxisPosition(index: u32) -> vec4<f32> {\n  return getAxisStep(0u) * f32(index) + getAxisOrigin(0u);\n}\n",
  "plot/grid": "@link fn getGridValue(i: u32) -> f32;\n@link fn getGridDirection(i: u32) -> i32;\n@link fn getGridMin(i: u32) -> vec4<f32>;\n@link fn getGridMax(i: u32) -> vec4<f32>;\n\nlet STEP = vec2<f32>(0.0, 1.0);\n\n@export fn getGridPosition(index: u32) -> vec4<f32> {\n  let n = u32(LINE_DETAIL + 1);\n\n  let i = index / n;\n  let v = f32(index % n) / f32(n - 1u);\n\n  let base = mix(getGridMin(0u), getGridMax(0u), v);\n\n  let dir = getGridDirection(0u);\n  var step: vec4<f32>;\n  if      (dir == 0) { step = STEP.yxxx; }\n  else if (dir == 1) { step = STEP.xyxx; }\n  else if (dir == 2) { step = STEP.xxyx; }\n  else               { step = STEP.xxxy; }\n\n  return base + step * getGridValue(i);\n}\n",
  "@use-gpu/wgsl/plot/grid": "@link fn getGridValue(i: u32) -> f32;\n@link fn getGridDirection(i: u32) -> i32;\n@link fn getGridMin(i: u32) -> vec4<f32>;\n@link fn getGridMax(i: u32) -> vec4<f32>;\n\nlet STEP = vec2<f32>(0.0, 1.0);\n\n@export fn getGridPosition(index: u32) -> vec4<f32> {\n  let n = u32(LINE_DETAIL + 1);\n\n  let i = index / n;\n  let v = f32(index % n) / f32(n - 1u);\n\n  let base = mix(getGridMin(0u), getGridMax(0u), v);\n\n  let dir = getGridDirection(0u);\n  var step: vec4<f32>;\n  if      (dir == 0) { step = STEP.yxxx; }\n  else if (dir == 1) { step = STEP.xyxx; }\n  else if (dir == 2) { step = STEP.xxyx; }\n  else               { step = STEP.xxxy; }\n\n  return base + step * getGridValue(i);\n}\n",
  "plot/scale": "@link fn getScaleValue(i: u32) -> f32;\n@link fn getScaleDirection(i: u32) -> i32;\n@link fn getScaleOrigin(i: u32) -> vec4<f32>;\n\nlet STEP = vec2<f32>(0.0, 1.0);\n\n@export fn getScalePosition(index: u32) -> vec4<f32> {\n  \n  let dir = getScaleDirection(0u);\n\n  var step: vec4<f32>;\n  if (dir == 0) { step = STEP.yxxx; }\n  if (dir == 1) { step = STEP.xyxx; }\n  if (dir == 2) { step = STEP.xxyx; }\n  if (dir == 3) { step = STEP.xxxy; }\n  \n  return getScaleOrigin(0u) + step * getScaleValue(index);\n}\n",
  "@use-gpu/wgsl/plot/scale": "@link fn getScaleValue(i: u32) -> f32;\n@link fn getScaleDirection(i: u32) -> i32;\n@link fn getScaleOrigin(i: u32) -> vec4<f32>;\n\nlet STEP = vec2<f32>(0.0, 1.0);\n\n@export fn getScalePosition(index: u32) -> vec4<f32> {\n  \n  let dir = getScaleDirection(0u);\n\n  var step: vec4<f32>;\n  if (dir == 0) { step = STEP.yxxx; }\n  if (dir == 1) { step = STEP.xyxx; }\n  if (dir == 2) { step = STEP.xxyx; }\n  if (dir == 3) { step = STEP.xxxy; }\n  \n  return getScaleOrigin(0u) + step * getScaleValue(index);\n}\n",
  "plot/surface": "use '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\n\n@link fn getSize(i: u32) -> vec4<u32> {};\n@optional @link fn getPosition(index: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\nfn sizeToModulus(size: vec4<u32>) -> vec3<u32> {\n  let n = size.x * size.y;\n  return vec3<u32>(size.x, n, 0xffffffffu);\n}\n\n// Index an [x,y] x [x+1,y+1] quad on a surface\n@export fn getSurfaceIndex(index: u32) -> u32 {\n  let vertex = index % 6u;\n  let instance = index / 6u;\n  let s = getSize(0u);\n\n  var dx = 1u;\n  var dy = 1u;\n  if (LOOP_X) { dx = 0u; }\n  if (LOOP_Y) { dy = 0u; }\n\n  let size = s - vec4<u32>(dx, dy, 0u, 0u);\n  let modulus = sizeToModulus(size);\n\n  var xy = getStripIndex(vertex - (vertex / 3u) * 2u);\n  if (vertex < 3u) { xy = xy.yx; }\n\n  let xyd = offsetIndex(unpackIndex(instance, modulus), s, vec2<i32>(xy));\n\n  return packIndex(xyd, sizeToModulus(s));\n}\n\n@export fn getSurfaceNormal(index: u32) -> vec4<f32> {\n  let size = getSize(0u);\n  let modulus = sizeToModulus(size);\n\n  let xyd = unpackIndex(index, modulus);\n  \n  let left   = packIndex(offsetIndex(xyd, size, vec2<i32>(-1, 0)), modulus);\n  let right  = packIndex(offsetIndex(xyd, size, vec2<i32>(1, 0)), modulus);\n  let top    = packIndex(offsetIndex(xyd, size, vec2<i32>(0, -1)), modulus);\n  let bottom = packIndex(offsetIndex(xyd, size, vec2<i32>(0, 1)), modulus);\n\n  let dx = getPosition(right) - getPosition(left);\n  let dy = getPosition(bottom) - getPosition(top);\n\n  let normal = vec4<f32>(normalize(cross(dx.xyz, dy.xyz)), 0.0);\n  return normal;\n}\n\nfn packIndex(index: vec3<u32>, modulus: vec3<u32>) -> u32 {\n  let offsets = index * vec3<u32>(1u, modulus.xy);\n  return dot(offsets, vec3<u32>(1u, 1u, 1u));\n}\n\nfn unpackIndex(index: u32, modulus: vec3<u32>) -> vec3<u32> {\n  var d = index % modulus;\n  return d / vec3<u32>(1u, modulus.xy);\n}\n\nfn offsetIndex(index: vec3<u32>, size: vec4<u32>, offset: vec2<i32>) -> vec3<u32> {\n  var sx = i32(index.x) + offset.x;\n  if (LOOP_X) {\n    if (sx < 0) { sx = sx + i32(size.x); }\n    if (sx >= i32(size.x)) { sx = sx - i32(size.x); }\n  }\n  else {\n    if (sx < 0) { sx = 0; }\n    if (sx >= i32(size.x)) { sx = i32(size.x) - 1; }\n  }\n\n  var sy = i32(index.y) + offset.y;\n  if (LOOP_Y) {\n    if (sy < 0) { sy = sy + i32(size.y); }\n    if (sy >= i32(size.y)) { sy = sy - i32(size.y); }\n  }\n  else {\n    if (sy < 0) { sy = 0; }\n    if (sy >= i32(size.y)) { sy = i32(size.y) - 1; }\n  }\n  \n  return vec3<u32>(u32(sx), u32(sy), index.z);\n}\n",
  "@use-gpu/wgsl/plot/surface": "use '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\n\n@link fn getSize(i: u32) -> vec4<u32> {};\n@optional @link fn getPosition(index: u32) -> vec4<f32> { return vec4<f32>(0.0, 0.0, 0.0, 0.0); }\n\nfn sizeToModulus(size: vec4<u32>) -> vec3<u32> {\n  let n = size.x * size.y;\n  return vec3<u32>(size.x, n, 0xffffffffu);\n}\n\n// Index an [x,y] x [x+1,y+1] quad on a surface\n@export fn getSurfaceIndex(index: u32) -> u32 {\n  let vertex = index % 6u;\n  let instance = index / 6u;\n  let s = getSize(0u);\n\n  var dx = 1u;\n  var dy = 1u;\n  if (LOOP_X) { dx = 0u; }\n  if (LOOP_Y) { dy = 0u; }\n\n  let size = s - vec4<u32>(dx, dy, 0u, 0u);\n  let modulus = sizeToModulus(size);\n\n  var xy = getStripIndex(vertex - (vertex / 3u) * 2u);\n  if (vertex < 3u) { xy = xy.yx; }\n\n  let xyd = offsetIndex(unpackIndex(instance, modulus), s, vec2<i32>(xy));\n\n  return packIndex(xyd, sizeToModulus(s));\n}\n\n@export fn getSurfaceNormal(index: u32) -> vec4<f32> {\n  let size = getSize(0u);\n  let modulus = sizeToModulus(size);\n\n  let xyd = unpackIndex(index, modulus);\n  \n  let left   = packIndex(offsetIndex(xyd, size, vec2<i32>(-1, 0)), modulus);\n  let right  = packIndex(offsetIndex(xyd, size, vec2<i32>(1, 0)), modulus);\n  let top    = packIndex(offsetIndex(xyd, size, vec2<i32>(0, -1)), modulus);\n  let bottom = packIndex(offsetIndex(xyd, size, vec2<i32>(0, 1)), modulus);\n\n  let dx = getPosition(right) - getPosition(left);\n  let dy = getPosition(bottom) - getPosition(top);\n\n  let normal = vec4<f32>(normalize(cross(dx.xyz, dy.xyz)), 0.0);\n  return normal;\n}\n\nfn packIndex(index: vec3<u32>, modulus: vec3<u32>) -> u32 {\n  let offsets = index * vec3<u32>(1u, modulus.xy);\n  return dot(offsets, vec3<u32>(1u, 1u, 1u));\n}\n\nfn unpackIndex(index: u32, modulus: vec3<u32>) -> vec3<u32> {\n  var d = index % modulus;\n  return d / vec3<u32>(1u, modulus.xy);\n}\n\nfn offsetIndex(index: vec3<u32>, size: vec4<u32>, offset: vec2<i32>) -> vec3<u32> {\n  var sx = i32(index.x) + offset.x;\n  if (LOOP_X) {\n    if (sx < 0) { sx = sx + i32(size.x); }\n    if (sx >= i32(size.x)) { sx = sx - i32(size.x); }\n  }\n  else {\n    if (sx < 0) { sx = 0; }\n    if (sx >= i32(size.x)) { sx = i32(size.x) - 1; }\n  }\n\n  var sy = i32(index.y) + offset.y;\n  if (LOOP_Y) {\n    if (sy < 0) { sy = sy + i32(size.y); }\n    if (sy >= i32(size.y)) { sy = sy - i32(size.y); }\n  }\n  else {\n    if (sy < 0) { sy = 0; }\n    if (sy >= i32(size.y)) { sy = i32(size.y) - 1; }\n  }\n  \n  return vec3<u32>(u32(sx), u32(sy), index.z);\n}\n",
  "render/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light-old'::{ lightUniforms };\n\n@group(1) @binding(0) var t: texture_2d<f32>;\n@group(1) @binding(1) var s: sampler;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>,\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "@use-gpu/wgsl/render/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light-old'::{ lightUniforms };\n\n@group(1) @binding(0) var t: texture_2d<f32>;\n@group(1) @binding(1) var s: sampler;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>,\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "render/fragment/pick": "@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n) -> @location(0) vec4<u32> {\n  return vec4<u32>(fragId, fragIndex, 0u, 0u);\n}\n\n",
  "@use-gpu/wgsl/render/fragment/pick": "@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n) -> @location(0) vec4<u32> {\n  return vec4<u32>(fragId, fragIndex, 0u, 0u);\n}\n\n",
  "render/fragment/shaded": "@optional @link fn getFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec3<f32>,\n  tangent: vec3<f32>,\n  position: vec3<f32>,\n) -> vec4<f32> { return color; }\n\n@stage(fragment)\nfn main(\n  @builtin(front_facing) frontFacing: bool,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec4<f32>,\n  @location(3) fragTangent: vec4<f32>,\n  @location(4) fragPosition: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n  var normal = fragNormal;\n  //if (!frontFacing) { normal = -normal; }\n\n  var outColor = fragColor;\n  outColor = getFragment(outColor, fragUV, normal, fragTangent, fragPosition);\n  if (outColor.a <= 0.0) { discard; }\n\n  return outColor;\n}\n",
  "@use-gpu/wgsl/render/fragment/shaded": "@optional @link fn getFragment(\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  normal: vec3<f32>,\n  tangent: vec3<f32>,\n  position: vec3<f32>,\n) -> vec4<f32> { return color; }\n\n@stage(fragment)\nfn main(\n  @builtin(front_facing) frontFacing: bool,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec4<f32>,\n  @location(3) fragTangent: vec4<f32>,\n  @location(4) fragPosition: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n  var normal = fragNormal;\n  //if (!frontFacing) { normal = -normal; }\n\n  var outColor = fragColor;\n  outColor = getFragment(outColor, fragUV, normal, fragTangent, fragPosition);\n  if (outColor.a <= 0.0) { discard; }\n\n  return outColor;\n}\n",
  "render/fragment/solid": "@optional @link fn getFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> { return color; }\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,  \n) -> @location(0) vec4<f32> {\n  var outColor = fragColor;\n\n  outColor = getFragment(outColor, fragUV);\n  if (outColor.a <= 0.0) { discard; }\n\n  return outColor;\n}\n",
  "@use-gpu/wgsl/render/fragment/solid": "@optional @link fn getFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> { return color; }\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,  \n) -> @location(0) vec4<f32> {\n  var outColor = fragColor;\n\n  outColor = getFragment(outColor, fragUV);\n  if (outColor.a <= 0.0) { discard; }\n\n  return outColor;\n}\n",
  "render/fragment/ui": "@link fn getFragment(\n  fragUV: vec2<f32>,\n  fragTextureUV: vec2<f32>,\n  fragSDFUV: vec2<f32>,\n  fragSDFConfig: vec4<f32>,\n  fragRepeat: i32,\n  fragMode: i32,\n  fragLayout: vec4<f32>,\n  fragRadius: vec4<f32>,\n  fragBorder: vec4<f32>,\n  fragStroke: vec4<f32>,\n  fragFill: vec4<f32>,\n) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0)                     fragUV: vec2<f32>,\n  @location(1)                     fragTextureUV: vec2<f32>,\n  @location(2)                     fragClipUV: vec4<f32>,\n  @location(3)                     fragSDFUV: vec2<f32>,\n  @location(4)  @interpolate(flat) fragSDFConfig: vec4<f32>,\n  @location(5)  @interpolate(flat) fragRepeat: i32,\n  @location(6)  @interpolate(flat) fragMode: i32,\n  @location(7)  @interpolate(flat) fragLayout: vec4<f32>,\n  @location(8)  @interpolate(flat) fragRadius: vec4<f32>,\n  @location(9)  @interpolate(flat) fragBorder: vec4<f32>,\n  @location(10) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(11) @interpolate(flat) fragFill: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n  return getFragment(\n    fragUV,\n    fragTextureUV,\n    fragClipUV,\n    fragSDFUV,\n    fragSDFConfig,\n    fragRepeat,\n    fragMode,\n    fragLayout,\n    fragRadius,\n    fragBorder,\n    fragStroke,\n    fragFill,\n  );\n}",
  "@use-gpu/wgsl/render/fragment/ui": "@link fn getFragment(\n  fragUV: vec2<f32>,\n  fragTextureUV: vec2<f32>,\n  fragSDFUV: vec2<f32>,\n  fragSDFConfig: vec4<f32>,\n  fragRepeat: i32,\n  fragMode: i32,\n  fragLayout: vec4<f32>,\n  fragRadius: vec4<f32>,\n  fragBorder: vec4<f32>,\n  fragStroke: vec4<f32>,\n  fragFill: vec4<f32>,\n) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0)                     fragUV: vec2<f32>,\n  @location(1)                     fragTextureUV: vec2<f32>,\n  @location(2)                     fragClipUV: vec4<f32>,\n  @location(3)                     fragSDFUV: vec2<f32>,\n  @location(4)  @interpolate(flat) fragSDFConfig: vec4<f32>,\n  @location(5)  @interpolate(flat) fragRepeat: i32,\n  @location(6)  @interpolate(flat) fragMode: i32,\n  @location(7)  @interpolate(flat) fragLayout: vec4<f32>,\n  @location(8)  @interpolate(flat) fragRadius: vec4<f32>,\n  @location(9)  @interpolate(flat) fragBorder: vec4<f32>,\n  @location(10) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(11) @interpolate(flat) fragFill: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n  return getFragment(\n    fragUV,\n    fragTextureUV,\n    fragClipUV,\n    fragSDFUV,\n    fragSDFConfig,\n    fragRepeat,\n    fragMode,\n    fragLayout,\n    fragRadius,\n    fragBorder,\n    fragStroke,\n    fragFill,\n  );\n}",
  "render/vertex/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    u32(PICKING_ID),\n    fragIndex,\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    u32(PICKING_ID),\n    fragIndex,\n  );\n}\n",
  "render/vertex/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    toColorSpace(color),\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    toColorSpace(color),\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "render/vertex/virtual-pick": "use '@use-gpu/wgsl/use/types'::{ PickVertex };\n\n@link fn getVertex(v: u32, i: u32) -> PickVertex {};\n@optional @link fn getId() -> u32 { return 0u; };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    getId(),\n    v.index,\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/virtual-pick": "use '@use-gpu/wgsl/use/types'::{ PickVertex };\n\n@link fn getVertex(v: u32, i: u32) -> PickVertex {};\n@optional @link fn getId() -> u32 { return 0u; };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) @interpolate(flat) fragId: u32,\n  @location(1) @interpolate(flat) fragIndex: u32,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    getId(),\n    v.index,\n  );\n}\n",
  "render/vertex/virtual-shaded": "use '@use-gpu/wgsl/use/types'::{ ShadedVertex };\n\n@link fn getVertex(v: u32, i: u32) -> ShadedVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec4<f32>,\n  @location(3) fragTangent: vec4<f32>,\n  @location(4) fragPosition: vec4<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  let v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    toColorSpace(v.color),\n    v.uv,\n    v.normal,\n    v.tangent,\n    v.world,\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/virtual-shaded": "use '@use-gpu/wgsl/use/types'::{ ShadedVertex };\n\n@link fn getVertex(v: u32, i: u32) -> ShadedVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec4<f32>,\n  @location(3) fragTangent: vec4<f32>,\n  @location(4) fragPosition: vec4<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  let v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    toColorSpace(v.color),\n    v.uv,\n    v.normal,\n    v.tangent,\n    v.world,\n  );\n}\n",
  "render/vertex/virtual-solid": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  let v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    toColorSpace(v.color),\n    v.uv,\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/virtual-solid": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  let v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n    toColorSpace(v.color),\n    v.uv,\n  );\n}\n",
  "render/vertex/virtual-ui": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\n\n@link fn getVertex(v: u32, i: u32) -> UIVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n  \nstruct VertexOutput {\n  @builtin(position)               position: vec4<f32>,\n  @location(0)                     fragUV: vec2<f32>,\n  @location(1)                     fragTextureUV: vec2<f32>,\n  @location(2)                     fragClipUV: vec4<f32>,\n  @location(3)                     fragSDFUV: vec2<f32>,\n  @location(4)  @interpolate(flat) fragSDFConfig: vec4<f32>,\n  @location(5)  @interpolate(flat) fragRepeat: i32,\n  @location(6)  @interpolate(flat) fragMode: i32,\n  @location(7)  @interpolate(flat) fragLayout: vec4<f32>,\n  @location(8)  @interpolate(flat) fragRadius: vec4<f32>,\n  @location(9)  @interpolate(flat) fragBorder: vec4<f32>,\n  @location(10) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(11) @interpolate(flat) fragFill: vec4<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n\n    v.uv,\n    v.textureUV,\n    v.clipUV,\n    v.sdfUV,\n    v.sdfConfig,\n    v.repeat,\n    v.mode,\n    v.layout,\n    v.radius,\n    v.border,\n    toColorSpace(v.stroke),\n    toColorSpace(v.fill),\n  );\n}\n",
  "@use-gpu/wgsl/render/vertex/virtual-ui": "use '@use-gpu/wgsl/use/types'::{ UIVertex };\n\n@link fn getVertex(v: u32, i: u32) -> UIVertex {};\n@optional @link fn toColorSpace(c: vec4<f32>) -> vec4<f32> { return c; }\n  \nstruct VertexOutput {\n  @builtin(position)               position: vec4<f32>,\n  @location(0)                     fragUV: vec2<f32>,\n  @location(1)                     fragTextureUV: vec2<f32>,\n  @location(2)                     fragClipUV: vec4<f32>,\n  @location(3)                     fragSDFUV: vec2<f32>,\n  @location(4)  @interpolate(flat) fragSDFConfig: vec4<f32>,\n  @location(5)  @interpolate(flat) fragRepeat: i32,\n  @location(6)  @interpolate(flat) fragMode: i32,\n  @location(7)  @interpolate(flat) fragLayout: vec4<f32>,\n  @location(8)  @interpolate(flat) fragRadius: vec4<f32>,\n  @location(9)  @interpolate(flat) fragBorder: vec4<f32>,\n  @location(10) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(11) @interpolate(flat) fragFill: vec4<f32>,\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(vertexIndex, instanceIndex);\n\n  return VertexOutput(\n    v.position,\n\n    v.uv,\n    v.textureUV,\n    v.clipUV,\n    v.sdfUV,\n    v.sdfConfig,\n    v.repeat,\n    v.mode,\n    v.layout,\n    v.radius,\n    v.border,\n    toColorSpace(v.stroke),\n    toColorSpace(v.fill),\n  );\n}\n",
  "render/wireframe/wireframe-list": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@link fn getInstanceSize() -> u32 {};\n\n@export fn getWireframeListVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  let vi = vertexIndex;\n  var ij = getStripIndex(vi - (vi / 3u) * 2u);\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = getInstanceSize();\n  var f = instanceIndex % n;\n  var i = instanceIndex / n;\n\n  var v = u32(f) % 3u;\n  var t = u32(f) - v;\n\n  var ia: u32;\n  var ib: u32;\n  var ic: u32;\n  if (v == 0u) {\n    ia = t;\n    ib = t + 1u;\n    ic = t + 2u;\n  }\n  else if (v == 1u) {\n    ia = t + 1u;\n    ib = t + 2u;\n    ic = t;\n  }\n  else if (v == 2u) {\n    ia = t + 2u;\n    ib = t;\n    ic = t + 1u;\n  }\n\n  var a = getVertex(ia, i);\n  var b = getVertex(ib, i);\n  var c = getVertex(ic, i);\n  \n  if (a.position.w < 0.0 || b.position.w < 0.0 || c.position.w < 0.0) {\n    var NaN: f32 = bitcast<f32>(0xffffffffu);\n    return SolidVertex(\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec2<f32>(NaN, NaN),\n      0u,\n    );\n  }\n\n  var left  = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n  var other = c.position.xyz / c.position.w;\n\n  var join: vec3<f32>;\n  if (ij.x > 0u) {\n    join = getLineJoin(left, right, other, (f32(ij.x) - 1.0) / 2.0, xy.y, 2.0, 3, 2);\n  }\n  else {\n    join = getLineJoin(other, left, right, 1.0, xy.y, 2.0, 3, 2);\n  }\n\n  return SolidVertex(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n    0u,\n  );\n}\n",
  "@use-gpu/wgsl/render/wireframe/wireframe-list": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@link fn getInstanceSize() -> u32 {};\n\n@export fn getWireframeListVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  let vi = vertexIndex;\n  var ij = getStripIndex(vi - (vi / 3u) * 2u);\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = getInstanceSize();\n  var f = instanceIndex % n;\n  var i = instanceIndex / n;\n\n  var v = u32(f) % 3u;\n  var t = u32(f) - v;\n\n  var ia: u32;\n  var ib: u32;\n  var ic: u32;\n  if (v == 0u) {\n    ia = t;\n    ib = t + 1u;\n    ic = t + 2u;\n  }\n  else if (v == 1u) {\n    ia = t + 1u;\n    ib = t + 2u;\n    ic = t;\n  }\n  else if (v == 2u) {\n    ia = t + 2u;\n    ib = t;\n    ic = t + 1u;\n  }\n\n  var a = getVertex(ia, i);\n  var b = getVertex(ib, i);\n  var c = getVertex(ic, i);\n  \n  if (a.position.w < 0.0 || b.position.w < 0.0 || c.position.w < 0.0) {\n    var NaN: f32 = bitcast<f32>(0xffffffffu);\n    return SolidVertex(\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec2<f32>(NaN, NaN),\n      0u,\n    );\n  }\n\n  var left  = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n  var other = c.position.xyz / c.position.w;\n\n  var join: vec3<f32>;\n  if (ij.x > 0u) {\n    join = getLineJoin(left, right, other, (f32(ij.x) - 1.0) / 2.0, xy.y, 2.0, 3, 2);\n  }\n  else {\n    join = getLineJoin(other, left, right, 1.0, xy.y, 2.0, 3, 2);\n  }\n\n  return SolidVertex(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n    0u,\n  );\n}\n",
  "render/wireframe/wireframe-strip": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@link fn getInstanceSize() -> u32 {};\n\n@export fn getWireframeStripVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var ij = getQuadIndex(vertexIndex);\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = getInstanceSize();\n  var f = instanceIndex % n;\n  var i = instanceIndex / n;\n\n  var stripIndex = getStripIndex(f);\n  var edgeIndex = stripIndex.y;\n  var triIndex = stripIndex.x;\n\n  var a = getVertex(triIndex, i);\n  var b = getVertex(triIndex + 1u + edgeIndex, i);\n\n  var left = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n\n  if (a.position.w < 0.0 || b.position.w < 0.0) {\n    var NaN: f32 = bitcast<f32>(0xffffffffu);\n    return SolidVertex(\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec2<f32>(NaN, NaN),\n      0u,\n    );\n  }\n  \n  var join: vec3<f32>;\n  if (ij.x > 0u) {\n    join = getLineJoin(left, left, right, 0.0, xy.y, 2.0, 1, 0);\n  }\n  else {\n    join = getLineJoin(left, right, right, 0.0, xy.y, 2.0, 2, 0);\n  }\n\n  return SolidVertex(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n    0u,\n  );\n}\n",
  "@use-gpu/wgsl/render/wireframe/wireframe-strip": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@link fn getVertex(v: u32, i: u32) -> SolidVertex {};\n@link fn getInstanceSize() -> u32 {};\n\n@export fn getWireframeStripVertex(vertexIndex: u32, instanceIndex: u32) -> SolidVertex {\n  var ij = getQuadIndex(vertexIndex);\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = getInstanceSize();\n  var f = instanceIndex % n;\n  var i = instanceIndex / n;\n\n  var stripIndex = getStripIndex(f);\n  var edgeIndex = stripIndex.y;\n  var triIndex = stripIndex.x;\n\n  var a = getVertex(triIndex, i);\n  var b = getVertex(triIndex + 1u + edgeIndex, i);\n\n  var left = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n\n  if (a.position.w < 0.0 || b.position.w < 0.0) {\n    var NaN: f32 = bitcast<f32>(0xffffffffu);\n    return SolidVertex(\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec4<f32>(NaN, NaN, NaN, NaN),\n      vec2<f32>(NaN, NaN),\n      0u,\n    );\n  }\n  \n  var join: vec3<f32>;\n  if (ij.x > 0u) {\n    join = getLineJoin(left, left, right, 0.0, xy.y, 2.0, 1, 0);\n  }\n  else {\n    join = getLineJoin(left, right, right, 0.0, xy.y, 2.0, 2, 0);\n  }\n\n  return SolidVertex(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n    0u,\n  );\n}\n",
  "transform/cartesian": "@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getCartesianPosition(position: vec4<f32>) -> vec4<f32> {\n  let pos = vec4<f32>(position.xyz, 1.0);\n  return getMatrix() * pos;\n}\n",
  "@use-gpu/wgsl/transform/cartesian": "@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getCartesianPosition(position: vec4<f32>) -> vec4<f32> {\n  let pos = vec4<f32>(position.xyz, 1.0);\n  return getMatrix() * pos;\n}\n",
  "transform/normal": "@link fn getMatrix(i: u32) -> mat4x4<f32>;\n@link fn getNormal(i: u32) -> vec4<f32>;\n\n@export fn getTransformedNormal(i: u32) -> vec4<f32> {\n  let normal = getNormal(i);\n  let rotated = getMatrix(0u) * vec4<f32>(normal.xyz, 0.0);\n  return vec4<f32>(rotated.xyz, normal.w);\n}\n",
  "@use-gpu/wgsl/transform/normal": "@link fn getMatrix(i: u32) -> mat4x4<f32>;\n@link fn getNormal(i: u32) -> vec4<f32>;\n\n@export fn getTransformedNormal(i: u32) -> vec4<f32> {\n  let normal = getNormal(i);\n  let rotated = getMatrix(0u) * vec4<f32>(normal.xyz, 0.0);\n  return vec4<f32>(rotated.xyz, normal.w);\n}\n",
  "transform/polar": "@optional @link fn getPolarBend() -> f32 { return 0.0; };\n@optional @link fn getPolarFocus() -> f32 { return 0.0; };\n@optional @link fn getPolarAspect() -> f32 { return 1.0; };\n@optional @link fn getPolarHelix() -> f32 { return 0.0; };\n\n@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getPolarPosition(position: vec4<f32>) -> vec4<f32> {\n  let polarBend = getPolarBend();\n  let polarFocus = getPolarFocus();\n  let polarAspect = getPolarAspect();\n  let polarHelix = getPolarHelix();\n\n  let matrix = getMatrix();\n\n  if (polarBend > 0.0) {\n\n    if (polarBend < 0.001) {\n      // Factor out large addition/subtraction of polarFocus\n      // to avoid numerical error\n      // sin(x) ~ x\n      // cos(x) ~ 1 - x * x / 2\n      let pb = position.xy * polarBend;\n      let ppbbx = pb.x * pb.x;\n      return matrix * vec4(\n        position.x * (1.0 - polarBend + (pb.y * polarAspect)),\n        position.y * (1.0 - .5 * ppbbx) - (.5 * ppbbx) * polarFocus / polarAspect,\n        position.z + position.x * polarHelix * polarBend,\n        1.0\n      );\n    }\n    else {\n      let xy = position.xy * vec2<f32>(polarBend, polarAspect);\n      let radius = polarFocus + xy.y;\n      return matrix * vec4<f32>(\n        sin(xy.x) * radius,\n        (cos(xy.x) * radius - polarFocus) / polarAspect,\n        position.z + position.x * polarHelix * polarBend,\n        1.0\n      );\n    }\n  }\n  else {\n    return matrix * vec4<f32>(position.xyz, 1.0);\n  }\n}\n",
  "@use-gpu/wgsl/transform/polar": "@optional @link fn getPolarBend() -> f32 { return 0.0; };\n@optional @link fn getPolarFocus() -> f32 { return 0.0; };\n@optional @link fn getPolarAspect() -> f32 { return 1.0; };\n@optional @link fn getPolarHelix() -> f32 { return 0.0; };\n\n@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getPolarPosition(position: vec4<f32>) -> vec4<f32> {\n  let polarBend = getPolarBend();\n  let polarFocus = getPolarFocus();\n  let polarAspect = getPolarAspect();\n  let polarHelix = getPolarHelix();\n\n  let matrix = getMatrix();\n\n  if (polarBend > 0.0) {\n\n    if (polarBend < 0.001) {\n      // Factor out large addition/subtraction of polarFocus\n      // to avoid numerical error\n      // sin(x) ~ x\n      // cos(x) ~ 1 - x * x / 2\n      let pb = position.xy * polarBend;\n      let ppbbx = pb.x * pb.x;\n      return matrix * vec4(\n        position.x * (1.0 - polarBend + (pb.y * polarAspect)),\n        position.y * (1.0 - .5 * ppbbx) - (.5 * ppbbx) * polarFocus / polarAspect,\n        position.z + position.x * polarHelix * polarBend,\n        1.0\n      );\n    }\n    else {\n      let xy = position.xy * vec2<f32>(polarBend, polarAspect);\n      let radius = polarFocus + xy.y;\n      return matrix * vec4<f32>(\n        sin(xy.x) * radius,\n        (cos(xy.x) * radius - polarFocus) / polarAspect,\n        position.z + position.x * polarHelix * polarBend,\n        1.0\n      );\n    }\n  }\n  else {\n    return matrix * vec4<f32>(position.xyz, 1.0);\n  }\n}\n",
  "transform/spherical": "@optional @link fn getSphericalBend() -> f32 { return 0.0; };\n@optional @link fn getSphericalFocus() -> f32 { return 0.0; };\n@optional @link fn getSphericalAspectX() -> f32 { return 1.0; };\n@optional @link fn getSphericalAspectY() -> f32 { return 1.0; };\n@optional @link fn getSphericalScaleY() -> f32 { return 0.0; };\n\n@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getSphericalPosition(position: vec4<f32>) -> vec4<f32> {\n  let sphericalBend = getSphericalBend();\n  let sphericalFocus = getSphericalFocus();\n  let sphericalAspectX = getSphericalAspectX();\n  let sphericalAspectY = getSphericalAspectY();\n  let sphericalScaleY = getSphericalScaleY();\n\n  let matrix = getMatrix();\n\n  if (sphericalBend > 0.0001) {\n    let xyz = position.xyz * vec3<f32>(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);\n    let radius = sphericalFocus + xyz.z;\n    let cosine = cos(xyz.y) * radius;\n\n    return matrix * vec4<f32>(\n      sin(xyz.x) * cosine,\n      sin(xyz.y) * radius * sphericalAspectY,\n      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,\n      1.0\n    );\n  }\n  else {\n    return matrix * vec4<f32>(position.xyz, 1.0);\n  }\n}\n",
  "@use-gpu/wgsl/transform/spherical": "@optional @link fn getSphericalBend() -> f32 { return 0.0; };\n@optional @link fn getSphericalFocus() -> f32 { return 0.0; };\n@optional @link fn getSphericalAspectX() -> f32 { return 1.0; };\n@optional @link fn getSphericalAspectY() -> f32 { return 1.0; };\n@optional @link fn getSphericalScaleY() -> f32 { return 0.0; };\n\n@link fn getMatrix() -> mat4x4<f32>;\n\n@export fn getSphericalPosition(position: vec4<f32>) -> vec4<f32> {\n  let sphericalBend = getSphericalBend();\n  let sphericalFocus = getSphericalFocus();\n  let sphericalAspectX = getSphericalAspectX();\n  let sphericalAspectY = getSphericalAspectY();\n  let sphericalScaleY = getSphericalScaleY();\n\n  let matrix = getMatrix();\n\n  if (sphericalBend > 0.0001) {\n    let xyz = position.xyz * vec3<f32>(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);\n    let radius = sphericalFocus + xyz.z;\n    let cosine = cos(xyz.y) * radius;\n\n    return matrix * vec4<f32>(\n      sin(xyz.x) * cosine,\n      sin(xyz.y) * radius * sphericalAspectY,\n      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,\n      1.0\n    );\n  }\n  else {\n    return matrix * vec4<f32>(position.xyz, 1.0);\n  }\n}\n",
  "use/color": "@export fn premultiply(color: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(color.rgb * color.a, color.a);\n}\n",
  "@use-gpu/wgsl/use/color": "@export fn premultiply(color: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(color.rgb * color.a, color.a);\n}\n",
  "use/gamma": "let gamma = 2.2;\n\n@export fn toLinear(v: f32) -> f32 {\n  return pow(v, gamma);\n}\n\n@export fn toLinear2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(gamma));\n}\n\n@export fn toLinear3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(gamma));\n}\n\n@export fn toLinear4(v: vec4<f32>) -> vec4<f32> {\n  return vec4(toLinear3(v.rgb), v.a);\n}\n\n@export fn toGamma(v: f32) -> f32 {\n  return pow(v, 1.0 / gamma);\n}\n\n@export fn toGamma2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(1.0 / gamma));\n}\n\n@export fn toGamma3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(1.0 / gamma));\n}\n\n@export fn toGamma4(v: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(toGamma3(v.rgb), v.a);\n}\n",
  "@use-gpu/wgsl/use/gamma": "let gamma = 2.2;\n\n@export fn toLinear(v: f32) -> f32 {\n  return pow(v, gamma);\n}\n\n@export fn toLinear2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(gamma));\n}\n\n@export fn toLinear3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(gamma));\n}\n\n@export fn toLinear4(v: vec4<f32>) -> vec4<f32> {\n  return vec4(toLinear3(v.rgb), v.a);\n}\n\n@export fn toGamma(v: f32) -> f32 {\n  return pow(v, 1.0 / gamma);\n}\n\n@export fn toGamma2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(1.0 / gamma));\n}\n\n@export fn toGamma3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(1.0 / gamma));\n}\n\n@export fn toGamma4(v: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(toGamma3(v.rgb), v.a);\n}\n",
  "use/light-old": "struct LightUniforms {\n  lightPosition: vec4<f32>,\n  lightColor: vec4<f32>,\n};\n\n@export @group(LIGHT) @binding(LIGHT) var<uniform> lightUniforms: LightUniforms;\n",
  "@use-gpu/wgsl/use/light-old": "struct LightUniforms {\n  lightPosition: vec4<f32>,\n  lightColor: vec4<f32>,\n};\n\n@export @group(LIGHT) @binding(LIGHT) var<uniform> lightUniforms: LightUniforms;\n",
  "use/light": "struct Light {\n  kind: i32,\n  position: vec4<f32>,\n  color: vec4<f32>,\n  intensity: f32,\n};\n",
  "@use-gpu/wgsl/use/light": "struct Light {\n  kind: i32,\n  position: vec4<f32>,\n  color: vec4<f32>,\n  intensity: f32,\n};\n",
  "use/types": "@export struct PickVertex {\n  position: vec4<f32>,\n  index: u32,\n};\n\n@export struct SolidVertex {\n  position: vec4<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  index: u32,\n};\n\n@export struct ShadedVertex {\n  position: vec4<f32>,\n  world: vec4<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n\n  index: u32,\n};\n\n@export struct UIVertex {\n  position: vec4<f32>,\n\n  uv: vec2<f32>,\n  sdfConfig: vec4<f32>,\n  sdfUV: vec2<f32>,\n  clipUV: vec4<f32>,\n  textureUV: vec2<f32>,\n  repeat: i32,\n\n  mode: i32,\n  layout: vec4<f32>,\n  radius: vec4<f32>,\n  border: vec4<f32>,\n  stroke: vec4<f32>,\n  fill: vec4<f32>,\n\n  index: u32,\n};\n\n////\n\n@export struct MeshVertex {\n  position: vec4<f32>,\n  normal: vec3<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n\n  index: u32,\n};",
  "@use-gpu/wgsl/use/types": "@export struct PickVertex {\n  position: vec4<f32>,\n  index: u32,\n};\n\n@export struct SolidVertex {\n  position: vec4<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n  index: u32,\n};\n\n@export struct ShadedVertex {\n  position: vec4<f32>,\n  world: vec4<f32>,\n  normal: vec4<f32>,\n  tangent: vec4<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n\n  index: u32,\n};\n\n@export struct UIVertex {\n  position: vec4<f32>,\n\n  uv: vec2<f32>,\n  sdfConfig: vec4<f32>,\n  sdfUV: vec2<f32>,\n  clipUV: vec4<f32>,\n  textureUV: vec2<f32>,\n  repeat: i32,\n\n  mode: i32,\n  layout: vec4<f32>,\n  radius: vec4<f32>,\n  border: vec4<f32>,\n  stroke: vec4<f32>,\n  fill: vec4<f32>,\n\n  index: u32,\n};\n\n////\n\n@export struct MeshVertex {\n  position: vec4<f32>,\n  normal: vec3<f32>,\n  color: vec4<f32>,\n  uv: vec2<f32>,\n\n  index: u32,\n};",
  "use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  viewPosition: vec4<f32>,\n  viewNearFar: vec2<f32>,\n  viewResolution: vec2<f32>,\n  viewSize: vec2<f32>,\n  viewWorldDepth: vec2<f32>,\n  viewPixelRatio: f32,\n};\n\n@export @group(VIEW) @binding(VIEW) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn getViewPosition() -> vec4<f32> { return viewUniforms.viewPosition; }\n@export fn getViewResolution() -> vec2<f32> { return viewUniforms.viewResolution; }\n@export fn getViewSize() -> vec2<f32> { return viewUniforms.viewSize; }\n@export fn getViewNearFar() -> vec2<f32> { return viewUniforms.viewNearFar; }\n\n@export fn to3D(position: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(position.xyz, 1.0);\n}\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn toClip3D(position: vec4<f32>) -> vec3<f32> {\n  return position.xyz / position.w;\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return toClip3D(worldToClip(position));\n}\n\n@export fn clip3DToScreen(position: vec3<f32>) -> vec2<f32> {\n  return position.xy * viewUniforms.viewSize;\n}\n\n@export fn screenToClip3D(position: vec2<f32>, z: f32) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, z);\n}\n\n@export fn clipLineIntoView(anchor: vec4<f32>, head: vec4<f32>) -> vec4<f32> {\n  let near = viewUniforms.viewNearFar.x * 2.0;\n\n  let d = anchor - head;\n  if (dot(d, d) == 0.0) { return worldToView(anchor); }\n\n  let a = worldToView(anchor);\n  let b = worldToView(head);\n\n  if (-a.z < near) {\n    if (abs(b.z - a.z) > 0.001) {\n      let ratio = (near + a.z) / (a.z - b.z);\n      return mix(a, b, ratio);\n    }\n  }\n\n  return a;\n}\n\n@export fn getViewScale() -> f32 {\n  let m = viewUniforms.projectionMatrix;\n  return 2.0 / length(m[1]);\n}\n\n@export fn getWorldScale(w: f32, f: f32) -> f32 {\n  let v = viewUniforms.viewResolution;\n  return getPerspectiveScale(w, f) * v.y * w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  let m = viewUniforms.projectionMatrix;\n  let worldScale = length(m[1]) * viewUniforms.viewWorldDepth.x;\n  let clipScale = mix(1.0, worldScale / w, f);\n  let pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n\n@export fn applyZBias3(position: vec3<f32>, zBias: f32, w: f32) -> vec3<f32> {\n  let m = viewUniforms.projectionMatrix;\n  let v = viewUniforms.viewResolution;\n  let zw = m[2].w;\n\n  if (zw < 0.0) {\n    // reversed z - perspective\n    let z = m[3].z / (-w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec3<f32>(position.xy, -z);\n  }\n  else if (zw > 0.0) {\n    // normal z - perspective\n    let z = m[3].z / (w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec3<f32>(position.xy, z);\n  }\n  else {\n    // orthographic\n    let w = (position.z - m[3].z) / m[2].z;\n    var z = (w - zBias * v.y * viewUniforms.viewWorldDepth.y) * m[2].z + m[3].z;\n    return vec3<f32>(position.xy, z);\n  }\n}\n\n@export fn applyZBias(position: vec4<f32>, zBias: f32) -> vec4<f32> {\n  let m = viewUniforms.projectionMatrix;\n  let v = viewUniforms.viewResolution;\n  let w = position.w;\n\n  let zw = m[2].w;\n  if (zw < 0.0) {\n    // reversed z - perspective\n    let z = m[3].z / (-w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec4<f32>(position.xy, -z * w, w);\n  }\n  else if (zw > 0.0) {\n    // normal z - perspective\n    let z = m[3].z / (w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec4<f32>(position.xy, z * w, w);\n  }\n  else {\n    // orthographic\n    let w = (position.z - m[3].z) / m[2].z;\n    let z = (w - zBias * v.y * viewUniforms.viewWorldDepth.y) * m[2].z + m[3].z;\n    return vec4<f32>(position.xy, z, 1.0);\n  }\n}\n\n",
  "@use-gpu/wgsl/use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>,\n  viewMatrix: mat4x4<f32>,\n  viewPosition: vec4<f32>,\n  viewNearFar: vec2<f32>,\n  viewResolution: vec2<f32>,\n  viewSize: vec2<f32>,\n  viewWorldDepth: vec2<f32>,\n  viewPixelRatio: f32,\n};\n\n@export @group(VIEW) @binding(VIEW) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn getViewPosition() -> vec4<f32> { return viewUniforms.viewPosition; }\n@export fn getViewResolution() -> vec2<f32> { return viewUniforms.viewResolution; }\n@export fn getViewSize() -> vec2<f32> { return viewUniforms.viewSize; }\n@export fn getViewNearFar() -> vec2<f32> { return viewUniforms.viewNearFar; }\n\n@export fn to3D(position: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(position.xyz, 1.0);\n}\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn toClip3D(position: vec4<f32>) -> vec3<f32> {\n  return position.xyz / position.w;\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return toClip3D(worldToClip(position));\n}\n\n@export fn clip3DToScreen(position: vec3<f32>) -> vec2<f32> {\n  return position.xy * viewUniforms.viewSize;\n}\n\n@export fn screenToClip3D(position: vec2<f32>, z: f32) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, z);\n}\n\n@export fn clipLineIntoView(anchor: vec4<f32>, head: vec4<f32>) -> vec4<f32> {\n  let near = viewUniforms.viewNearFar.x * 2.0;\n\n  let d = anchor - head;\n  if (dot(d, d) == 0.0) { return worldToView(anchor); }\n\n  let a = worldToView(anchor);\n  let b = worldToView(head);\n\n  if (-a.z < near) {\n    if (abs(b.z - a.z) > 0.001) {\n      let ratio = (near + a.z) / (a.z - b.z);\n      return mix(a, b, ratio);\n    }\n  }\n\n  return a;\n}\n\n@export fn getViewScale() -> f32 {\n  let m = viewUniforms.projectionMatrix;\n  return 2.0 / length(m[1]);\n}\n\n@export fn getWorldScale(w: f32, f: f32) -> f32 {\n  let v = viewUniforms.viewResolution;\n  return getPerspectiveScale(w, f) * v.y * w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  let m = viewUniforms.projectionMatrix;\n  let worldScale = length(m[1]) * viewUniforms.viewWorldDepth.x;\n  let clipScale = mix(1.0, worldScale / w, f);\n  let pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n\n@export fn applyZBias3(position: vec3<f32>, zBias: f32, w: f32) -> vec3<f32> {\n  let m = viewUniforms.projectionMatrix;\n  let v = viewUniforms.viewResolution;\n  let zw = m[2].w;\n\n  if (zw < 0.0) {\n    // reversed z - perspective\n    let z = m[3].z / (-w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec3<f32>(position.xy, -z);\n  }\n  else if (zw > 0.0) {\n    // normal z - perspective\n    let z = m[3].z / (w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec3<f32>(position.xy, z);\n  }\n  else {\n    // orthographic\n    let w = (position.z - m[3].z) / m[2].z;\n    var z = (w - zBias * v.y * viewUniforms.viewWorldDepth.y) * m[2].z + m[3].z;\n    return vec3<f32>(position.xy, z);\n  }\n}\n\n@export fn applyZBias(position: vec4<f32>, zBias: f32) -> vec4<f32> {\n  let m = viewUniforms.projectionMatrix;\n  let v = viewUniforms.viewResolution;\n  let w = position.w;\n\n  let zw = m[2].w;\n  if (zw < 0.0) {\n    // reversed z - perspective\n    let z = m[3].z / (-w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec4<f32>(position.xy, -z * w, w);\n  }\n  else if (zw > 0.0) {\n    // normal z - perspective\n    let z = m[3].z / (w + w * zBias * v.y * viewUniforms.viewWorldDepth.y) + m[2].z;\n    return vec4<f32>(position.xy, z * w, w);\n  }\n  else {\n    // orthographic\n    let w = (position.z - m[3].z) / m[2].z;\n    let z = (w - zBias * v.y * viewUniforms.viewWorldDepth.y) * m[2].z + m[3].z;\n    return vec4<f32>(position.xy, z, 1.0);\n  }\n}\n\n"
};
export default WGSLModules;
