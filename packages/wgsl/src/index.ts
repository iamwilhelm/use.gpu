// File generated by build.ts. Do not edit directly.
// This file provides all the shader code in a statically importable form, used for testing.
export const WGSLModules = {
  "fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = albedo * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = (Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "@use-gpu/wgsl/fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = albedo * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = (Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "instance/draw/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    fragIndex,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    fragIndex,\n  );\n}\n",
  "instance/draw/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n  @location(2) fragNormal: vec3<f32>;\n  @location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    color,\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n  @location(2) fragNormal: vec3<f32>;\n  @location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    color,\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "instance/fragment/mesh-pick": "use '@use-gpu/glsl/use/picking'::{ getPickingColor }\n\n//@group(1) @binding(0) var s: sampler;\n//@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragIndex: u32,\n) -> FragmentOutput {\n  var outColor = getPickingColor(fragIndex);\n\n  return FragmentOutput(outColor);\n}\n",
  "@use-gpu/wgsl/instance/fragment/mesh-pick": "use '@use-gpu/glsl/use/picking'::{ getPickingColor }\n\n//@group(1) @binding(0) var s: sampler;\n//@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragIndex: u32,\n) -> FragmentOutput {\n  var outColor = getPickingColor(fragIndex);\n\n  return FragmentOutput(outColor);\n}\n",
  "instance/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light'::{ lightUniforms };\n\n@group(1) @binding(0) var s: sampler;\n@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "@use-gpu/wgsl/instance/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light'::{ lightUniforms };\n\n@group(1) @binding(0) var s: sampler;\n@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "use/light": "struct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n//@group(LIGHT_BINDGROUP) @binding(LIGHT_BINDING) var<uniform> lightUniforms: LightUniforms;\n@group(0) @binding(1) var<uniform> lightUniforms: LightUniforms;\n",
  "@use-gpu/wgsl/use/light": "struct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n//@group(LIGHT_BINDGROUP) @binding(LIGHT_BINDING) var<uniform> lightUniforms: LightUniforms;\n@group(0) @binding(1) var<uniform> lightUniforms: LightUniforms;\n",
  "use/picking": "struct PickingUniforms {\n  pickingId: u32;\n};\n\n//@group(PICKING_BINDGROUP) @binding(PICKING_BINDING) var<uniform> pickingUniforms: PickingUniforms;\n@group(0) @binding(1) var<uniform> pickingUniforms: PickingUniforms;\n\n@export fn getPickingColor(fragIndex: u32) -> vec4<u32> {\n  var r = pickingUniforms.pickingId;\n  var g = fragIndex;\n  return vec4<u32>(r, g, 0, 0);\n}\n",
  "@use-gpu/wgsl/use/picking": "struct PickingUniforms {\n  pickingId: u32;\n};\n\n//@group(PICKING_BINDGROUP) @binding(PICKING_BINDING) var<uniform> pickingUniforms: PickingUniforms;\n@group(0) @binding(1) var<uniform> pickingUniforms: PickingUniforms;\n\n@export fn getPickingColor(fragIndex: u32) -> vec4<u32> {\n  var r = pickingUniforms.pickingId;\n  var g = fragIndex;\n  return vec4<u32>(r, g, 0, 0);\n}\n",
  "use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n//@export @group(VIEW_BINDGROUP) @binding(VIEW_BINDING) var<uniform> viewUniforms: ViewUniforms;\n@export @group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn clipToScreen3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewSize, position.z);\n}\n\n@export fn screenToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, position.z);\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  position = viewToClip(worldToView(position));\n  return position.xyz / position.w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  var m = viewUniforms.projectionMatrix;\n  var worldScale = m[1][1] * viewUniforms.viewWorldUnit;\n  var clipScale = mix(1.0, worldScale / w, f);\n  var pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n",
  "@use-gpu/wgsl/use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n//@export @group(VIEW_BINDGROUP) @binding(VIEW_BINDING) var<uniform> viewUniforms: ViewUniforms;\n@export @group(0) @binding(0) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn clipToScreen3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewSize, position.z);\n}\n\n@export fn screenToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, position.z);\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  position = viewToClip(worldToView(position));\n  return position.xyz / position.w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  var m = viewUniforms.projectionMatrix;\n  var worldScale = m[1][1] * viewUniforms.viewWorldUnit;\n  var clipScale = mix(1.0, worldScale / w, f);\n  var pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n"
};
export default WGSLModules;
