// File generated by build.ts. Do not edit directly.
// This file provides all the shader code in a statically importable form, used for testing.
export const WGSLModules = {
  "fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = albedo * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = (Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "@use-gpu/wgsl/fragment/pbr": "// https://www.shadertoy.com/view/XlKSDR\n\nlet PI = 3.141592;\nlet F_DIELECTRIC = 0.04;\n\nfn saturate(x: f32) -> f32 {\n  return max(x, 0.0);\n}\n\nfn pow5(x: f32) -> f32 {\n  var x2 = x * x;\n  return x2 * x2 * x;\n}\n\n// D - Normal distribution term\nfn ndfGGX2(cosTheta: f32, alpha: f32) -> f32 {\n  var alphaSqr = alpha * alpha;\n  var denom = cosTheta * cosTheta * (alphaSqr - 1.0) + 1.0f;\n  return alphaSqr / (PI * denom * denom);\n}\n\nfn ndfGGX(cosTheta: f32, alpha: f32) -> f32 {\n  var oneMinus = 1.0 - cosTheta * cosTheta;\n  var a = cosTheta * alpha;\n  var k = alpha / (oneMinus + a * a);\n  var d = k * k * (1.0 / PI);\n  return d;\n}\n\n// F - Schlick approximation of Fresnel\nfn fresnelSchlickVec3(cosTheta: f32, f0: vec3<f32>) -> vec3<f32> {\n  var ft = pow5(1.0 - cosTheta);\n  return f0 + (1.0 - f0) * ft;\n}\n\nfn fresnelSchlick(cosTheta: f32, f0: f32, f90: f32) -> f32 {\n  return f0 + (f90 - f0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn fdBurley(dotNL: f32, dotNV: f32, dotLH: f32, alpha: f32) -> f32 {\n  var f90 = 0.5 + 2.0 * alpha * dotLH * dotLH;\n  var lightScatter = fresnelSchlick(dotNL, 1.0, f90);\n  var viewScatter = fresnelSchlick(dotNV, 1.0, f90);\n  return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// G - Geometric attenuation term\nfn smithGGXCorrelated(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var a2 = alpha * alpha;\n  var GGXL = dotNV * sqrt((dotNL - a2 * dotNL) * dotNL + a2);\n  var GGXV = dotNL * sqrt((dotNV - a2 * dotNV) * dotNV + a2);\n  return 0.5 / (GGXL + GGXV);\n}\n\nfn G1X(dotNX: f32, k: f32) -> f32 {\n  return 1.0f / (dotNX * (1.0f - k) + k);\n}\n\nfn geometricGGX(dotNL: f32, dotNV: f32, alpha: f32) -> f32 {\n  var k = alpha / 2.0f;\n  return G1X(dotNL, k) * G1X(dotNV, k);\n}\n\n// N, L, V must be normalized\n@export fn PBR(\n  N: vec3<f32>,\n  L: vec3<f32>,\n  V: vec3<f32>,\n  albedo: vec3<f32>,\n  metalness: f32,\n  roughness: f32,\n) -> vec3<f32> {\n\n  var diffuseColor = albedo * (1.0 - metalness);\n  var F0 = mix(vec3(F_DIELECTRIC), albedo, metalness);\n\n  var alpha = roughness * roughness;\n  var dotNV = saturate(dot(N, V));\n\n  var radiance = 3.1415;\n\n  var H = normalize(V + L);\n  var dotNL = saturate(dot(N, L));\n  var dotNH = saturate(dot(N, H));\n  var dotLH = saturate(dot(L, H));\n\n  var F = fresnelSchlickVec3(dotLH, F0);\n  var D = ndfGGX(dotNH, alpha);\n  var G = smithGGXCorrelated(dotNL, dotNV, alpha);\n  //float G2 = geometricGGX(dotNL, dotNV, alpha);\n  \n  var Fd = albedo * fdBurley(dotNL, dotNV, dotLH, alpha);\n  var Fs = F * D * G;\n\n  var direct = (Fd + Fs) * radiance * dotNL;\n  return direct;\n}\n",
  "geometry/line": "use '@use-gpu/wgsl/use/view'::{ viewUniforms };\n\n// segments\n//\n// o--o--o  o--o--o--o  o--o\n// 1  3  2  1  3  3  2  1  2\n\nfn turn(xy: vec2<f32>) -> vec2<f32> {\n  return vec2<f32>(xy.y, -xy.x);\n}\n\nfn slerp(d: f32, a: vec2<f32>, b: vec2<f32>, t: f32) -> vec2<f32> {\n  var th = acos(d);\n  var ab = sin(vec2((1.0 - t) * th, t * th));\n  return normalize(a * ab.x + b * ab.y);\n}\n\n@export fn lineJoinBevel(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  if (arc > 0.0) { return right; }\n  return left;\n}\n\n@export fn lineJoinMiter(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n  var scale = 1.0;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  mid = normalize((left + right) / 2.0);\n  scale = min(2.0, 1.0 / max(0.001, dot(mid, left)));\n\n  return mid * scale;\n}\n\n@export fn lineJoinRound(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  var d = dot(left, right);\n  if (d > 0.999) { return left; }\n  return slerp(d, left, right, arc);\n}\n\n@export fn getLineJoin(\n  beforePoint: vec3<f32>,\n  centerPoint: vec3<f32>,\n  afterPoint: vec3<f32>,\n  arc: f32,\n  y: f32,\n  size: f32,\n  segment: i32,\n  style: i32,\n) -> vec3<f32> {\n  var before = beforePoint.xy * viewUniforms.viewSize;\n  var center = centerPoint.xy * viewUniforms.viewSize;\n  var after = afterPoint.xy * viewUniforms.viewSize;\n\n  var left = turn(normalize(center - before));\n  var right = turn(normalize(after - center));\n\n  var mid: vec2<f32>;\n  if (segment == 2) {\n    mid = left;\n  }\n  else if (segment == 1) {\n    mid = right;\n  }\n  else {\n    var c = cross(vec3(left, 0.0), vec3(right, 0.0)).z;\n    if (c * y < 0.0) {\n      mid = lineJoinMiter(left, right, segment, arc);\n    }\n    else {\n      if (style == 0) { mid = lineJoinBevel(left, right, segment, arc); }\n      if (style == 1) { mid = lineJoinMiter(left, right, segment, arc); }\n      if (style == 2) { mid = lineJoinRound(left, right, segment, arc); }\n    }\n  }\n\n  var offset = size * mid * y;\n  // TODO: awaiting compound support\n  //center += offset;\n  center = center + offset;\n\n  return vec3<f32>(center * viewUniforms.viewResolution, centerPoint.z);\n}\n",
  "@use-gpu/wgsl/geometry/line": "use '@use-gpu/wgsl/use/view'::{ viewUniforms };\n\n// segments\n//\n// o--o--o  o--o--o--o  o--o\n// 1  3  2  1  3  3  2  1  2\n\nfn turn(xy: vec2<f32>) -> vec2<f32> {\n  return vec2<f32>(xy.y, -xy.x);\n}\n\nfn slerp(d: f32, a: vec2<f32>, b: vec2<f32>, t: f32) -> vec2<f32> {\n  var th = acos(d);\n  var ab = sin(vec2((1.0 - t) * th, t * th));\n  return normalize(a * ab.x + b * ab.y);\n}\n\n@export fn lineJoinBevel(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  if (arc > 0.0) { return right; }\n  return left;\n}\n\n@export fn lineJoinMiter(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n  var scale = 1.0;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  mid = normalize((left + right) / 2.0);\n  scale = min(2.0, 1.0 / max(0.001, dot(mid, left)));\n\n  return mid * scale;\n}\n\n@export fn lineJoinRound(left: vec2<f32>, right: vec2<f32>, segment: i32, arc: f32) -> vec2<f32> {\n  var mid: vec2<f32>;\n\n  if (arc == 0.0) { return left; }\n  if (arc == 1.0) { return right; }\n\n  var d = dot(left, right);\n  if (d > 0.999) { return left; }\n  return slerp(d, left, right, arc);\n}\n\n@export fn getLineJoin(\n  beforePoint: vec3<f32>,\n  centerPoint: vec3<f32>,\n  afterPoint: vec3<f32>,\n  arc: f32,\n  y: f32,\n  size: f32,\n  segment: i32,\n  style: i32,\n) -> vec3<f32> {\n  var before = beforePoint.xy * viewUniforms.viewSize;\n  var center = centerPoint.xy * viewUniforms.viewSize;\n  var after = afterPoint.xy * viewUniforms.viewSize;\n\n  var left = turn(normalize(center - before));\n  var right = turn(normalize(after - center));\n\n  var mid: vec2<f32>;\n  if (segment == 2) {\n    mid = left;\n  }\n  else if (segment == 1) {\n    mid = right;\n  }\n  else {\n    var c = cross(vec3(left, 0.0), vec3(right, 0.0)).z;\n    if (c * y < 0.0) {\n      mid = lineJoinMiter(left, right, segment, arc);\n    }\n    else {\n      if (style == 0) { mid = lineJoinBevel(left, right, segment, arc); }\n      if (style == 1) { mid = lineJoinMiter(left, right, segment, arc); }\n      if (style == 2) { mid = lineJoinRound(left, right, segment, arc); }\n    }\n  }\n\n  var offset = size * mid * y;\n  // TODO: awaiting compound support\n  //center += offset;\n  center = center + offset;\n\n  return vec3<f32>(center * viewUniforms.viewResolution, centerPoint.z);\n}\n",
  "geometry/quad": "let QUAD: array<vec2<i32>, 4> = array<vec2<i32>, 4>(\n  vec2<i32>(0, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, 1),\n  vec2<i32>(1, 1),\n);\n\n@export fn getQuadIndex(vertex: i32) -> vec2<i32> {\n  return QUAD[vertex];\n}\n\n@export fn getQuadUV(vertex: i32) -> vec2<f32> {\n  return vec2<f32>(getQuadIndex(vertex));\n}\n\n",
  "@use-gpu/wgsl/geometry/quad": "let QUAD: array<vec2<i32>, 4> = array<vec2<i32>, 4>(\n  vec2<i32>(0, 0),\n  vec2<i32>(1, 0),\n  vec2<i32>(0, 1),\n  vec2<i32>(1, 1),\n);\n\n@export fn getQuadIndex(vertex: i32) -> vec2<i32> {\n  return QUAD[vertex];\n}\n\n@export fn getQuadUV(vertex: i32) -> vec2<f32> {\n  return vec2<f32>(getQuadIndex(vertex));\n}\n\n",
  "geometry/strip": "@export fn getStripIndex(vertex: i32) -> vec2<i32> {\n  var x = vertex >> 1u;\n  var y = vertex & 1;\n  return vec2<i32>(x, y);\n}\n\n@export fn getStripUV(vertex: i32) -> vec2<f32> {\n  return vec2<f32>(getStripIndex(vertex));\n}\n\n",
  "@use-gpu/wgsl/geometry/strip": "@export fn getStripIndex(vertex: i32) -> vec2<i32> {\n  var x = vertex >> 1u;\n  var y = vertex & 1;\n  return vec2<i32>(x, y);\n}\n\n@export fn getStripUV(vertex: i32) -> vec2<f32> {\n  return vec2<f32>(getStripIndex(vertex));\n}\n\n",
  "instance/draw/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    fragIndex,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/mesh-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  var fragIndex = u32(instanceIndex);\n  \n  return VertexOutput(\n    outPosition,\n    fragIndex,\n  );\n}\n",
  "instance/draw/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n  @location(2) fragNormal: vec3<f32>;\n  @location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    color,\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/mesh": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n  @location(2) fragNormal: vec3<f32>;\n  @location(3) fragPosition: vec3<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(instance_index) instanceIndex: u32,\n  @location(0) position: vec4<f32>,\n  @location(1) normal: vec4<f32>,\n  @location(2) color: vec4<f32>,\n  @location(3) uv: vec2<f32>,\n) -> VertexOutput {\n  \n  var outPosition: vec4<f32> = worldToClip(position);\n  \n  return VertexOutput(\n    outPosition,\n    color,\n    uv,\n    normal.xyz,\n    position.xyz,\n  );\n}\n",
  "instance/draw/virtual-pick": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(i32(vertexIndex), i32(instanceIndex));\n\n  return VertexOutput(\n    v.position,\n    instanceIndex,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/virtual-pick": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) @interpolate(flat) fragIndex: u32;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(i32(vertexIndex), i32(instanceIndex));\n\n  return VertexOutput(\n    v.position,\n    instanceIndex,\n  );\n}\n",
  "instance/draw/virtual": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(i32(vertexIndex), i32(instanceIndex));\n\n  return VertexOutput(\n    v.position,\n    v.color,\n    v.uv,\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/virtual": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n  var v = getVertex(i32(vertexIndex), i32(instanceIndex));\n\n  return VertexOutput(\n    v.position,\n    v.color,\n    v.uv,\n  );\n}\n",
  "instance/draw/wireframe-strip": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var ij = getQuadIndex(i32(vertexIndex));\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = STRIP_SEGMENTS * 2 + 1;\n  var f = i32(instanceIndex) % n;\n  var i = i32(instanceIndex) / n;\n\n  var stripIndex = getStripIndex(f);\n  var edgeIndex = stripIndex.y;\n  var triIndex = stripIndex.x;\n\n  var a = getVertex(triIndex, i);\n  var b = getVertex(triIndex + 1 + edgeIndex, i);\n\n  var left = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n\n  var join: vec3<f32>;\n  if (ij.x > 0) {\n    join = getLineJoin(left, left, right, 0.0, xy.y, 2.0, 1, 0);\n  }\n  else {\n    join = getLineJoin(left, right, right, 0.0, xy.y, 2.0, 2, 0);\n  }\n\n  return VertexOutput(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n  );\n}\n",
  "@use-gpu/wgsl/instance/draw/wireframe-strip": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadIndex };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@external fn getVertex(v: i32, i: i32) -> SolidVertex {};\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>;\n  @location(0) fragColor: vec4<f32>;\n  @location(1) fragUV: vec2<f32>;\n};\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var ij = getQuadIndex(i32(vertexIndex));\n  var xy = vec2<f32>(ij) * 2.0 - 1.0;\n\n  var n = STRIP_SEGMENTS * 2 + 1;\n  var f = i32(instanceIndex) % n;\n  var i = i32(instanceIndex) / n;\n\n  var stripIndex = getStripIndex(f);\n  var edgeIndex = stripIndex.y;\n  var triIndex = stripIndex.x;\n\n  var a = getVertex(triIndex, i);\n  var b = getVertex(triIndex + 1 + edgeIndex, i);\n\n  var left = a.position.xyz / a.position.w;\n  var right = b.position.xyz / b.position.w;\n\n  var join: vec3<f32>;\n  if (ij.x > 0) {\n    join = getLineJoin(left, left, right, 0.0, xy.y, 2.0, 1, 0);\n  }\n  else {\n    join = getLineJoin(left, right, right, 0.0, xy.y, 2.0, 2, 0);\n  }\n\n  return VertexOutput(\n    vec4<f32>(join, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    vec2<f32>(0.0, 0.0),\n  );\n}\n",
  "instance/fragment/mesh-pick": "use '@use-gpu/wgsl/use/picking'::{ getPickingColor }\n\n//@group(1) @binding(0) var s: sampler;\n//@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<u32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragIndex: u32,\n) -> FragmentOutput {\n  var outColor = getPickingColor(fragIndex);\n\n  return FragmentOutput(outColor);\n}\n",
  "@use-gpu/wgsl/instance/fragment/mesh-pick": "use '@use-gpu/wgsl/use/picking'::{ getPickingColor }\n\n//@group(1) @binding(0) var s: sampler;\n//@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<u32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragIndex: u32,\n) -> FragmentOutput {\n  var outColor = getPickingColor(fragIndex);\n\n  return FragmentOutput(outColor);\n}\n",
  "instance/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light'::{ lightUniforms };\n\n@group(1) @binding(0) var s: sampler;\n@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "@use-gpu/wgsl/instance/fragment/mesh": "use '@use-gpu/wgsl/fragment/pbr'::{ PBR };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\nuse '@use-gpu/wgsl/use/light'::{ lightUniforms };\n\n@group(1) @binding(0) var s: sampler;\n@group(1) @binding(1) var t: texture_2d<f32>;\n\nstruct FragmentOutput {\n  @location(0) outColor: vec4<f32>;\n};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,\n  @location(2) fragNormal: vec3<f32>,\n  @location(3) fragPosition: vec3<f32>,\n) -> FragmentOutput {\n  var fragLight: vec3<f32> = lightUniforms.lightPosition.xyz - fragPosition;\n  var fragView: vec3<f32> = viewUniforms.viewPosition.xyz - fragPosition;\n\n  var N: vec3<f32> = normalize(fragNormal);\n  var L: vec3<f32> = normalize(fragLight);\n  var V: vec3<f32> = normalize(fragView);\n\n  var texColor: vec4<f32> = textureSample(t, s, fragUV);\n  var inColor: vec4<f32> = fragColor * texColor;\n  if (inColor.a <= 0.0) { discard; }\n\n  var albedo: vec3<f32> = inColor.rgb;\n  var metalness: f32 = 0.2;\n  var roughness: f32 = 0.8;\n\n  var color: vec3<f32> = PBR(N, L, V, albedo, metalness, roughness) * lightUniforms.lightColor.xyz;\n  var outColor: vec4<f32> = vec4<f32>(color, inColor.a);\n\n  return FragmentOutput(outColor);\n}\n",
  "instance/fragment/solid-pick": "use '@use-gpu/wgsl/use/picking'::{ getPickingColor };\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragIndex: u32,\n) -> @location(0) vec4<u32> {\n  return getPickingColor(fragIndex);\n}\n\n",
  "@use-gpu/wgsl/instance/fragment/solid-pick": "use '@use-gpu/wgsl/use/picking'::{ getPickingColor };\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragIndex: u32,\n) -> @location(0) vec4<u32> {\n  return getPickingColor(fragIndex);\n}\n\n",
  "instance/fragment/solid": "@external fn getFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,  \n) -> @location(0) vec4<f32> {\n  var outColor = fragColor;\n\n  // TODO: awaiting compound support\n  //outColor.xyz *= outColor.a;\n  outColor = vec4<f32>(outColor.xyz * outColor.a, outColor.a);\n  outColor = getFragment(outColor, fragUV);\n\n  if (outColor.a <= 0.0) { discard; }\n  return outColor;\n}\n",
  "@use-gpu/wgsl/instance/fragment/solid": "@external fn getFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0) fragColor: vec4<f32>,\n  @location(1) fragUV: vec2<f32>,  \n) -> @location(0) vec4<f32> {\n  var outColor = fragColor;\n\n  // TODO: awaiting compound support\n  //outColor.xyz *= outColor.a;\n  outColor = vec4<f32>(outColor.xyz * outColor.a, outColor.a);\n  outColor = getFragment(outColor, fragUV);\n\n  if (outColor.a <= 0.0) { discard; }\n  return outColor;\n}\n",
  "instance/ui/fragment-pick": "use '@use-gpu/glsl/use/picking'::{ getPickingColor };\nuse './sdf'::{ SDF, getBorderBoxSDF, getRoundedBorderBoxSDF };\n\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32> {};\n\nlet NO_BORDER = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>,\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>,\n  @location(2) @interpolate(flat) fragMode: i32,\n  @location(3) @interpolate(flat) fragIndex: u32,\n  @location(4)                    fragUV: vec2<f32>,\n) -> @location(0) vec4<u32> {\n  var color = getPickingColor(fragIndex);\n  if (fragMode == 0) { return color; }\n\n  var sdf: SDF;\n  if (fragMode == 1) { sdf = getBorderBoxSDF(fragRectangle, NO_BORDER, fragUV); }\n  else { sdf = getRoundedBorderBoxSDF(fragRectangle, fragRadius, NO_BORDER, fragUV); }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n  if (mask == 0.0) { discard; }\n\n  return color;\n}\n",
  "@use-gpu/wgsl/instance/ui/fragment-pick": "use '@use-gpu/glsl/use/picking'::{ getPickingColor };\nuse './sdf'::{ SDF, getBorderBoxSDF, getRoundedBorderBoxSDF };\n\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32> {};\n\nlet NO_BORDER = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>,\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>,\n  @location(2) @interpolate(flat) fragMode: i32,\n  @location(3) @interpolate(flat) fragIndex: u32,\n  @location(4)                    fragUV: vec2<f32>,\n) -> @location(0) vec4<u32> {\n  var color = getPickingColor(fragIndex);\n  if (fragMode == 0) { return color; }\n\n  var sdf: SDF;\n  if (fragMode == 1) { sdf = getBorderBoxSDF(fragRectangle, NO_BORDER, fragUV); }\n  else { sdf = getRoundedBorderBoxSDF(fragRectangle, fragRadius, NO_BORDER, fragUV); }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n  if (mask == 0.0) { discard; }\n\n  return color;\n}\n",
  "instance/ui/fragment": "use './sdf'::{ SDF, getUVScale, getBorderBoxSDF, getRoundedBorderBoxSDF };\n\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>,\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>,\n  @location(2) @interpolate(flat) fragMode: i32,\n  @location(3) @interpolate(flat) fragBorder: vec4<f32>,\n  @location(4) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(5) @interpolate(flat) fragFill: vec4<f32>,\n  @location(6) @interpolate(flat) fragRepeat: i32,\n  @location(7)                    fragUV: vec2<f32>,\n  @location(8)                    fragTextureUV: vec2<f32>,\n) -> @location(0) vec4<f32> {\n  var fillColor = fragFill;\n\n  var texture = getTexture(fragTextureUV);\n  var sdf: SDF;\n  \n  if (fragRepeat < 0) {\n    var wh = fragRectangle.zw - fragRectangle.xy;\n    var scale = getUVScale(fragUV * wh) * fragRadius.x;\n    var d = (texture.a - 0.75) * f32(fragRadius.y) + 0.25;\n    sdf = SDF(d / scale, d / scale);\n  }\n  else {\n    if (texture.a > 0.0) {\n      if (fragRepeat == 0 || fragRepeat == 1) {\n        if (fragTextureUV.x < 0.0 || fragTextureUV.x > 1.0) { texture.a = 0.0; }\n      }\n      if (fragRepeat == 0 || fragRepeat == 2) {\n        if (fragTextureUV.y < 0.0 || fragTextureUV.y > 1.0) { texture.a = 0.0; }\n      }\n  \n      fillColor = vec4<f32>(\n        fillColor.rgb * fillColor.a * (1.0 - texture.a) + texture.rgb,\n        mix(fillColor.a, 1.0, texture.a),\n      );\n    }\n  \n    if (fillColor.a <= 0.0) { discard; }\n  \n    if (fragMode == 0) { return fillColor; }\n\n    if (fragMode == 1) { sdf = getBorderBoxSDF(fragRectangle, fragBorder, fragUV); }\n    else { sdf = getRoundedBorderBoxSDF(fragRectangle, fragRadius, fragBorder, fragUV); }\n  }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n  if (mask == 0.0) { discard; }\n\n  var color = mix(fragStroke, fillColor, clamp(sdf.inner + (1.0 - mask), 0.0, 1.0));\n  color = color * mask;\n\n  return color;\n}\n",
  "@use-gpu/wgsl/instance/ui/fragment": "use './sdf'::{ SDF, getUVScale, getBorderBoxSDF, getRoundedBorderBoxSDF };\n\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32> {};\n\n@stage(fragment)\nfn main(\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>,\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>,\n  @location(2) @interpolate(flat) fragMode: i32,\n  @location(3) @interpolate(flat) fragBorder: vec4<f32>,\n  @location(4) @interpolate(flat) fragStroke: vec4<f32>,\n  @location(5) @interpolate(flat) fragFill: vec4<f32>,\n  @location(6) @interpolate(flat) fragRepeat: i32,\n  @location(7)                    fragUV: vec2<f32>,\n  @location(8)                    fragTextureUV: vec2<f32>,\n) -> @location(0) vec4<f32> {\n  var fillColor = fragFill;\n\n  var texture = getTexture(fragTextureUV);\n  var sdf: SDF;\n  \n  if (fragRepeat < 0) {\n    var wh = fragRectangle.zw - fragRectangle.xy;\n    var scale = getUVScale(fragUV * wh) * fragRadius.x;\n    var d = (texture.a - 0.75) * f32(fragRadius.y) + 0.25;\n    sdf = SDF(d / scale, d / scale);\n  }\n  else {\n    if (texture.a > 0.0) {\n      if (fragRepeat == 0 || fragRepeat == 1) {\n        if (fragTextureUV.x < 0.0 || fragTextureUV.x > 1.0) { texture.a = 0.0; }\n      }\n      if (fragRepeat == 0 || fragRepeat == 2) {\n        if (fragTextureUV.y < 0.0 || fragTextureUV.y > 1.0) { texture.a = 0.0; }\n      }\n  \n      fillColor = vec4<f32>(\n        fillColor.rgb * fillColor.a * (1.0 - texture.a) + texture.rgb,\n        mix(fillColor.a, 1.0, texture.a),\n      );\n    }\n  \n    if (fillColor.a <= 0.0) { discard; }\n  \n    if (fragMode == 0) { return fillColor; }\n\n    if (fragMode == 1) { sdf = getBorderBoxSDF(fragRectangle, fragBorder, fragUV); }\n    else { sdf = getRoundedBorderBoxSDF(fragRectangle, fragRadius, fragBorder, fragUV); }\n  }\n\n  var mask = clamp(sdf.outer, 0.0, 1.0);\n  if (mask == 0.0) { discard; }\n\n  var color = mix(fragStroke, fillColor, clamp(sdf.inner + (1.0 - mask), 0.0, 1.0));\n  color = color * mask;\n\n  return color;\n}\n",
  "instance/ui/sdf": "@export struct SDF {\n  outer: f32;\n  inner: f32;\n};\n\n@export fn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  return (length(dx) + length(dy)) * 0.5;\n}\n\n@export fn getBorderBoxSDF(box: vec4<f32>, border: vec4<f32>, uv: vec2<f32>) -> SDF {\n  var wh = box.zw - box.xy;\n  var scale = getUVScale(uv * wh);\n\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * wh;\n\n  var d1 = max(xy.x, xy.y);\n  var outer = 0.5 - d1;\n\n  var bs = mix(border.xy, border.zw, nearest);\n  var b = max(bs.x, bs.y);\n\n  xy = xy + bs;\n  var d2 = max(xy.x, xy.y);\n  var inner = 0.5 - d2;\n\n  return SDF(outer / scale, inner / scale);\n}\n\n@export fn getRoundedBorderBoxSDF(box: vec4<f32>, radius: vec4<f32>, border: vec4<f32>, uv: vec2<f32>) -> SDF {\n  var wh = box.zw - box.xy;\n  var scale = getUVScale(uv * wh);\n\n  var nearest = round(uv);\n  var rs = mix(radius.xw, radius.yz, nearest.x);\n  var r = mix(rs.x, rs.y, nearest.y);\n\n  var bs = mix(border.xy, border.zw, nearest);\n  var b = max(bs.x, bs.y);\n\n  var xy = (abs(uv - .5) - .5) * wh;\n\n  var clip = max(vec2<f32>(0.0), xy + r);\n  var neg = min(0.0, max(xy.x, xy.y) + r);\n\n  var outer: f32;\n  var inner: f32;\n  outer = r + 0.5 - length(clip) - neg;\n  inner = outer;\n  if (b > 0.0) {\n    xy = xy + bs;\n    r = max(0.0, r - b);\n\n    var clip = max(vec2<f32>(0.0), xy + r);\n    var neg = min(0.0, max(xy.x, xy.y) + r);\n    inner = r + 0.5 - length(clip) - neg;\n  }\n\n  return SDF(outer / scale, inner / scale);\n}\n",
  "@use-gpu/wgsl/instance/ui/sdf": "@export struct SDF {\n  outer: f32;\n  inner: f32;\n};\n\n@export fn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  return (length(dx) + length(dy)) * 0.5;\n}\n\n@export fn getBorderBoxSDF(box: vec4<f32>, border: vec4<f32>, uv: vec2<f32>) -> SDF {\n  var wh = box.zw - box.xy;\n  var scale = getUVScale(uv * wh);\n\n  var nearest = round(uv);\n  var xy = (abs(uv - .5) - .5) * wh;\n\n  var d1 = max(xy.x, xy.y);\n  var outer = 0.5 - d1;\n\n  var bs = mix(border.xy, border.zw, nearest);\n  var b = max(bs.x, bs.y);\n\n  xy = xy + bs;\n  var d2 = max(xy.x, xy.y);\n  var inner = 0.5 - d2;\n\n  return SDF(outer / scale, inner / scale);\n}\n\n@export fn getRoundedBorderBoxSDF(box: vec4<f32>, radius: vec4<f32>, border: vec4<f32>, uv: vec2<f32>) -> SDF {\n  var wh = box.zw - box.xy;\n  var scale = getUVScale(uv * wh);\n\n  var nearest = round(uv);\n  var rs = mix(radius.xw, radius.yz, nearest.x);\n  var r = mix(rs.x, rs.y, nearest.y);\n\n  var bs = mix(border.xy, border.zw, nearest);\n  var b = max(bs.x, bs.y);\n\n  var xy = (abs(uv - .5) - .5) * wh;\n\n  var clip = max(vec2<f32>(0.0), xy + r);\n  var neg = min(0.0, max(xy.x, xy.y) + r);\n\n  var outer: f32;\n  var inner: f32;\n  outer = r + 0.5 - length(clip) - neg;\n  inner = outer;\n  if (b > 0.0) {\n    xy = xy + bs;\n    r = max(0.0, r - b);\n\n    var clip = max(vec2<f32>(0.0), xy + r);\n    var neg = min(0.0, max(xy.x, xy.y) + r);\n    inner = r + 0.5 - length(clip) - neg;\n  }\n\n  return SDF(outer / scale, inner / scale);\n}\n",
  "instance/ui/vertex-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\nstruct VertexOutput {\n  @builtin(position)              position: vec4<f32>;\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>;\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>;\n  @location(2) @interpolate(flat) fragMode: i32;\n  @location(3) @interpolate(flat) fragIndex: u32;\n  @location(4)                    fragUV: vec2<f32>;\n};\n\n@external fn getRectangle(i: i32) -> vec4<f32>;\n@external fn getRadius(i: i32) -> vec4<f32>;\n@external fn getUV(i: i32) -> vec4<f32>;\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var rectangle = getRectangle(i32(instanceIndex));\n  var radius = getRadius(i32(instanceIndex));\n\n  var uv = getQuadUV(vertexIndex);\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv), 0.5, 1.0);\n  var center = worldToClip(position);\n\n  var mode: i32;\n  if (length(radius + border) == 0.0) { mode = 0; }\n  else if (length(radius) == 0.0) { mode = 1; }\n  else { mode = 2; };\n\n  return VertexOutput(\n    center,\n    rectangle,\n    radius,\n    fragMode,\n    u32(instance_index),\n    uv,\n  );\n}\n",
  "@use-gpu/wgsl/instance/ui/vertex-pick": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\nstruct VertexOutput {\n  @builtin(position)              position: vec4<f32>;\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>;\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>;\n  @location(2) @interpolate(flat) fragMode: i32;\n  @location(3) @interpolate(flat) fragIndex: u32;\n  @location(4)                    fragUV: vec2<f32>;\n};\n\n@external fn getRectangle(i: i32) -> vec4<f32>;\n@external fn getRadius(i: i32) -> vec4<f32>;\n@external fn getUV(i: i32) -> vec4<f32>;\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var rectangle = getRectangle(i32(instanceIndex));\n  var radius = getRadius(i32(instanceIndex));\n\n  var uv = getQuadUV(vertexIndex);\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv), 0.5, 1.0);\n  var center = worldToClip(position);\n\n  var mode: i32;\n  if (length(radius + border) == 0.0) { mode = 0; }\n  else if (length(radius) == 0.0) { mode = 1; }\n  else { mode = 2; };\n\n  return VertexOutput(\n    center,\n    rectangle,\n    radius,\n    fragMode,\n    u32(instance_index),\n    uv,\n  );\n}\n",
  "instance/ui/vertex": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\nstruct VertexOutput {\n  @builtin(position)              position: vec4<f32>;\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>;\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>;\n  @location(2) @interpolate(flat) fragMode: i32;\n  @location(3) @interpolate(flat) fragBorder: vec4<f32>;\n  @location(4) @interpolate(flat) fragStroke: vec4<f32>;\n  @location(5) @interpolate(flat) fragFill: vec4<f32>;\n  @location(6) @interpolate(flat) fragRepeat: i32;\n  @location(7)                    fragUV: vec2<f32>;\n  @location(8)                    fragTextureUV: vec2<f32>;\n};\n\n@external fn getRectangle(i: i32) -> vec4<f32>;\n@external fn getRadius(i: i32) -> vec4<f32>;\n@external fn getBorder(i: i32) -> vec4<f32>;\n@external fn getFill(i: i32) -> vec4<f32>;\n@external fn getStroke(i: i32) -> vec4<f32>;\n@external fn getUV(i: i32) -> vec4<f32>;\n@external fn getRepeat(i: i32) -> i32;\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var rectangle = getRectangle(i32(instanceIndex));\n  var radius = getRadius(i32(instanceIndex));\n  var border = getBorder(i32(instanceIndex));\n  var fill = getFill(i32(instanceIndex));\n  var stroke = getStroke(i32(instanceIndex));\n  var uv4 = getUV(i32(instanceIndex));\n  var repeat = getRepeat(i32(instanceIndex));\n\n  var uv = getQuadUV(i32(vertexIndex));\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv), 0.5, 1.0);\n  var center = worldToClip(position);\n\n  var texUV = mix(uv4.xy, uv4.zw, uv);\n\n  var mode: i32;\n  if (length(radius + border) == 0.0) { mode = 0; }\n  else if (length(radius) == 0.0) { mode = 1; }\n  else { mode = 2; };\n\n  return VertexOutput(\n    center,\n    rectangle,\n    radius,\n    mode,\n    border,\n    stroke,\n    fill,\n    repeat,\n    uv,\n    texUV,\n  );\n}\n",
  "@use-gpu/wgsl/instance/ui/vertex": "use '@use-gpu/wgsl/use/view'::{ worldToClip };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\nstruct VertexOutput {\n  @builtin(position)              position: vec4<f32>;\n  @location(0) @interpolate(flat) fragRectangle: vec4<f32>;\n  @location(1) @interpolate(flat) fragRadius: vec4<f32>;\n  @location(2) @interpolate(flat) fragMode: i32;\n  @location(3) @interpolate(flat) fragBorder: vec4<f32>;\n  @location(4) @interpolate(flat) fragStroke: vec4<f32>;\n  @location(5) @interpolate(flat) fragFill: vec4<f32>;\n  @location(6) @interpolate(flat) fragRepeat: i32;\n  @location(7)                    fragUV: vec2<f32>;\n  @location(8)                    fragTextureUV: vec2<f32>;\n};\n\n@external fn getRectangle(i: i32) -> vec4<f32>;\n@external fn getRadius(i: i32) -> vec4<f32>;\n@external fn getBorder(i: i32) -> vec4<f32>;\n@external fn getFill(i: i32) -> vec4<f32>;\n@external fn getStroke(i: i32) -> vec4<f32>;\n@external fn getUV(i: i32) -> vec4<f32>;\n@external fn getRepeat(i: i32) -> i32;\n\n@stage(vertex)\nfn main(\n  @builtin(vertex_index) vertexIndex: u32,\n  @builtin(instance_index) instanceIndex: u32,\n) -> VertexOutput {\n\n  var rectangle = getRectangle(i32(instanceIndex));\n  var radius = getRadius(i32(instanceIndex));\n  var border = getBorder(i32(instanceIndex));\n  var fill = getFill(i32(instanceIndex));\n  var stroke = getStroke(i32(instanceIndex));\n  var uv4 = getUV(i32(instanceIndex));\n  var repeat = getRepeat(i32(instanceIndex));\n\n  var uv = getQuadUV(i32(vertexIndex));\n  var position = vec4<f32>(mix(rectangle.xy, rectangle.zw, uv), 0.5, 1.0);\n  var center = worldToClip(position);\n\n  var texUV = mix(uv4.xy, uv4.zw, uv);\n\n  var mode: i32;\n  if (length(radius + border) == 0.0) { mode = 0; }\n  else if (length(radius) == 0.0) { mode = 1; }\n  else { mode = 2; };\n\n  return VertexOutput(\n    center,\n    rectangle,\n    radius,\n    mode,\n    border,\n    stroke,\n    fill,\n    repeat,\n    uv,\n    texUV,\n  );\n}\n",
  "instance/vertex/full-screen": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\n\n@export fn getFullScreenVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  var zz = viewUniforms.viewSize;\n  \n  return SolidVertex(\n    vec4<f32>(xy.x, -xy.y, 0.5, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    uv,\n  );\n}",
  "@use-gpu/wgsl/instance/vertex/full-screen": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms };\n\n@export fn getFullScreenVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  var zz = viewUniforms.viewSize;\n  \n  return SolidVertex(\n    vec4<f32>(xy.x, -xy.y, 0.5, 1.0),\n    vec4<f32>(1.0, 1.0, 1.0, 1.0),\n    uv,\n  );\n}",
  "instance/vertex/line": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D, getPerspectiveScale };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@external fn getPosition(i: i32) -> vec4<f32> {};\n@external fn getSegment(i: i32) -> i32 {};\n@external fn getColor(i: i32) -> vec4<f32> {};\n@external fn getSize(i: i32) -> f32 {};\n@external fn getDepth(i: i32) -> f32 {};\n\n@export fn getLineVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var ij = getStripIndex(vertexIndex);\n\n  var segmentLeft = getSegment(instanceIndex);\n  if (segmentLeft == 0 || segmentLeft == 2) {\n    return SolidVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN)\n    );\n  }\n\n  var uv = vec2<f32>(ij);\n  var xy = uv * 2.0 - 1.0;\n\n  var cornerIndex: i32;\n  var joinIndex: i32;\n  if (ij.x == 0) {\n    joinIndex = LINE_JOIN_SIZE;\n    cornerIndex = instanceIndex;\n  }\n  else {\n    joinIndex = ij.x - 1;\n    cornerIndex = instanceIndex + 1;\n  }\n\n  var segment = getSegment(cornerIndex);\n  var color = getColor(cornerIndex);\n  var size = getSize(cornerIndex);\n  var depth = getDepth(cornerIndex);\n\n  var beforePos = getPosition(cornerIndex - 1);\n  var centerPos = getPosition(cornerIndex);\n  var afterPos = getPosition(cornerIndex + 1);\n\n  var before = worldToClip3D(beforePos);\n  var center = worldToClip(centerPos);\n  var after = worldToClip3D(afterPos);\n\n  // Lerp between fixed size and full perspective\n  var pixelScale = getPerspectiveScale(center.w, depth);\n  // TODO: awaiting compound support\n  // size *= pixelScale;\n  size = size * pixelScale;\n\n  var arc = f32(joinIndex) / f32(LINE_JOIN_SIZE);\n  var lineJoin = getLineJoin(before, center.xyz / center.w, after, arc, xy.y, size, segment, LINE_JOIN_STYLE);\n\n  return SolidVertex(\n    vec4<f32>(lineJoin, 1.0),\n    color,\n    uv\n  );\n}\n",
  "@use-gpu/wgsl/instance/vertex/line": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ worldToClip, worldToClip3D, getPerspectiveScale };\nuse '@use-gpu/wgsl/geometry/strip'::{ getStripIndex };\nuse '@use-gpu/wgsl/geometry/line'::{ getLineJoin };\n\n@external fn getPosition(i: i32) -> vec4<f32> {};\n@external fn getSegment(i: i32) -> i32 {};\n@external fn getColor(i: i32) -> vec4<f32> {};\n@external fn getSize(i: i32) -> f32 {};\n@external fn getDepth(i: i32) -> f32 {};\n\n@export fn getLineVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var NaN: f32 = bitcast<f32>(0xffffffffu);\n\n  var ij = getStripIndex(vertexIndex);\n\n  var segmentLeft = getSegment(instanceIndex);\n  if (segmentLeft == 0 || segmentLeft == 2) {\n    return SolidVertex(\n      vec4(NaN, NaN, NaN, NaN),\n      vec4(NaN, NaN, NaN, NaN),\n      vec2(NaN, NaN)\n    );\n  }\n\n  var uv = vec2<f32>(ij);\n  var xy = uv * 2.0 - 1.0;\n\n  var cornerIndex: i32;\n  var joinIndex: i32;\n  if (ij.x == 0) {\n    joinIndex = LINE_JOIN_SIZE;\n    cornerIndex = instanceIndex;\n  }\n  else {\n    joinIndex = ij.x - 1;\n    cornerIndex = instanceIndex + 1;\n  }\n\n  var segment = getSegment(cornerIndex);\n  var color = getColor(cornerIndex);\n  var size = getSize(cornerIndex);\n  var depth = getDepth(cornerIndex);\n\n  var beforePos = getPosition(cornerIndex - 1);\n  var centerPos = getPosition(cornerIndex);\n  var afterPos = getPosition(cornerIndex + 1);\n\n  var before = worldToClip3D(beforePos);\n  var center = worldToClip(centerPos);\n  var after = worldToClip3D(afterPos);\n\n  // Lerp between fixed size and full perspective\n  var pixelScale = getPerspectiveScale(center.w, depth);\n  // TODO: awaiting compound support\n  // size *= pixelScale;\n  size = size * pixelScale;\n\n  var arc = f32(joinIndex) / f32(LINE_JOIN_SIZE);\n  var lineJoin = getLineJoin(before, center.xyz / center.w, after, arc, xy.y, size, segment, LINE_JOIN_STYLE);\n\n  return SolidVertex(\n    vec4<f32>(lineJoin, 1.0),\n    color,\n    uv\n  );\n}\n",
  "instance/vertex/quad": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms, worldToClip, getPerspectiveScale }; \nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\n@external fn getPosition(i: i32) -> vec4<f32> {};\n@external fn getColor(i: i32) -> vec4<f32> {};\n@external fn getSize(i: i32) -> vec2<f32> {};\n@external fn getDepth(i: i32) -> f32 {};\n\n@export fn getQuadVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var position = getPosition(instanceIndex);\n  var color = getColor(instanceIndex);\n  var size = getSize(instanceIndex);\n  var depth = getDepth(instanceIndex);\n\n  var center = worldToClip(position);\n\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n  // TODO: awaiting compound support\n  //size *= pixelScale;\n  size = size * pixelScale;\n\n  if (HAS_EDGE_BLEED) {\n    xy = xy * (size + 0.5) / size;\n    uv = xy * .5 + .5;\n  }\n\n  // TODO: awaiting compound support\n  //center.xy += xy * size * viewUniforms.viewResolution * center.w;\n  center = vec4<f32>(center.xy + xy * size * viewUniforms.viewResolution * center.w, center.zw);\n\n  return SolidVertex(\n    center,\n    color,\n    uv\n  );\n}",
  "@use-gpu/wgsl/instance/vertex/quad": "use '@use-gpu/wgsl/use/types'::{ SolidVertex };\nuse '@use-gpu/wgsl/use/view'::{ viewUniforms, worldToClip, getPerspectiveScale }; \nuse '@use-gpu/wgsl/geometry/quad'::{ getQuadUV };\n\n@external fn getPosition(i: i32) -> vec4<f32> {};\n@external fn getColor(i: i32) -> vec4<f32> {};\n@external fn getSize(i: i32) -> vec2<f32> {};\n@external fn getDepth(i: i32) -> f32 {};\n\n@export fn getQuadVertex(vertexIndex: i32, instanceIndex: i32) -> SolidVertex {\n  var position = getPosition(instanceIndex);\n  var color = getColor(instanceIndex);\n  var size = getSize(instanceIndex);\n  var depth = getDepth(instanceIndex);\n\n  var center = worldToClip(position);\n\n  var uv = getQuadUV(vertexIndex);\n  var xy = uv * 2.0 - 1.0;\n  \n  // Lerp between fixed size and full perspective.\n  var pixelScale = getPerspectiveScale(center.w, depth);\n  // TODO: awaiting compound support\n  //size *= pixelScale;\n  size = size * pixelScale;\n\n  if (HAS_EDGE_BLEED) {\n    xy = xy * (size + 0.5) / size;\n    uv = xy * .5 + .5;\n  }\n\n  // TODO: awaiting compound support\n  //center.xy += xy * size * viewUniforms.viewResolution * center.w;\n  center = vec4<f32>(center.xy + xy * size * viewUniforms.viewResolution * center.w, center.zw);\n\n  return SolidVertex(\n    center,\n    color,\n    uv\n  );\n}",
  "mask/filtered": "@external fn getColor(color: vec4<f32>) -> vec4<f32>;\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getFilteredFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return getColor(color * getTexture(uv));\n}\n\n@export fn getFilteredTexture(uv: vec2<f32>) -> vec4<f32> {\n  return getColor(getTexture(uv));\n}\n",
  "@use-gpu/wgsl/mask/filtered": "@external fn getColor(color: vec4<f32>) -> vec4<f32>;\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getFilteredFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return getColor(color * getTexture(uv));\n}\n\n@export fn getFilteredTexture(uv: vec2<f32>) -> vec4<f32> {\n  return getColor(getTexture(uv));\n}\n",
  "mask/masked": "@external fn getMask(uv: vec2<f32>) -> f32;\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getMaskedFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  var c = color;\n  c = c * getMask(uv);\n  c = c * getTexture(uv);\n  return c;\n}\n",
  "@use-gpu/wgsl/mask/masked": "@external fn getMask(uv: vec2<f32>) -> f32;\n@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getMaskedFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  var c = color;\n  c = c * getMask(uv);\n  c = c * getTexture(uv);\n  return c;\n}\n",
  "mask/passthru": "@export fn getPassThruFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return color;\n}\n",
  "@use-gpu/wgsl/mask/passthru": "@export fn getPassThruFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  return color;\n}\n",
  "mask/point": "let OUTLINE = 0.4;\n\nfn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  // implicit factor 2 to account for uv -> xy map\n  return length(dx) + length(dy);\n}\n\nfn scaleSDF(sdf: f32, scale: f32) -> f32 {\n  var d = sdf / scale + 0.5;\n  return clamp(d, 0.0, 1.0);\n}\n\nfn outlineSDF(sdf: f32) -> f32 {\n  return min(sdf, OUTLINE - sdf);\n}\n\nfn circleSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - length(xy);\n}\n\nfn diamondSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - (abs(xy.x) + abs(xy.y));\n}\n\nfn squareSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - max(abs(xy.x), abs(xy.y));\n}\n\n@export fn circle(uv: vec2<f32>) -> f32 {\n  var l = circleSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamond(uv: vec2<f32>) -> f32 {\n  var l = diamondSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn square(uv: vec2<f32>) -> f32 {\n  var l = squareSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn circleOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(circleSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamondOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(diamondSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn squareOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(squareSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n",
  "@use-gpu/wgsl/mask/point": "let OUTLINE = 0.4;\n\nfn getUVScale(uv: vec2<f32>) -> f32 {\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  // implicit factor 2 to account for uv -> xy map\n  return length(dx) + length(dy);\n}\n\nfn scaleSDF(sdf: f32, scale: f32) -> f32 {\n  var d = sdf / scale + 0.5;\n  return clamp(d, 0.0, 1.0);\n}\n\nfn outlineSDF(sdf: f32) -> f32 {\n  return min(sdf, OUTLINE - sdf);\n}\n\nfn circleSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - length(xy);\n}\n\nfn diamondSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - (abs(xy.x) + abs(xy.y));\n}\n\nfn squareSDF(uv: vec2<f32>) -> f32 {\n  var xy = uv * 2.0 - 1.0;\n  return 1.0 - max(abs(xy.x), abs(xy.y));\n}\n\n@export fn circle(uv: vec2<f32>) -> f32 {\n  var l = circleSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamond(uv: vec2<f32>) -> f32 {\n  var l = diamondSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn square(uv: vec2<f32>) -> f32 {\n  var l = squareSDF(uv);\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn circleOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(circleSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn diamondOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(diamondSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n\n@export fn squareOutlined(uv: vec2<f32>) -> f32 {\n  var l = outlineSDF(squareSDF(uv));\n  var s = getUVScale(uv);\n  return scaleSDF(l, s);\n}\n",
  "mask/textured": "@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getTextureFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  var c = color;\n  c = c * getTexture(uv);\n  return c;\n}\n",
  "@use-gpu/wgsl/mask/textured": "@external fn getTexture(uv: vec2<f32>) -> vec4<f32>;\n\n@export fn getTextureFragment(color: vec4<f32>, uv: vec2<f32>) -> vec4<f32> {\n  var c = color;\n  c = c * getTexture(uv);\n  return c;\n}\n",
  "use/gamma": "let gamma = 2.2;\n\n@export fn toLinear(v: f32) -> f32 {\n  return pow(v, gamma);\n}\n\n@export fn toLinear2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(gamma));\n}\n\n@export fn toLinear3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(gamma));\n}\n\n@export fn toLinear4(v: vec4<f32>) -> vec4<f32> {\n  return vec4(toLinear3(v.rgb), v.a);\n}\n\n@export fn toGamma(v: f32) -> f32 {\n  return pow(v, 1.0 / gamma);\n}\n\n@export fn toGamma2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(1.0 / gamma));\n}\n\n@export fn toGamma3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(1.0 / gamma));\n}\n\n@export fn toGamma4(v: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(toGamma3(v.rgb), v.a);\n}\n",
  "@use-gpu/wgsl/use/gamma": "let gamma = 2.2;\n\n@export fn toLinear(v: f32) -> f32 {\n  return pow(v, gamma);\n}\n\n@export fn toLinear2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(gamma));\n}\n\n@export fn toLinear3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(gamma));\n}\n\n@export fn toLinear4(v: vec4<f32>) -> vec4<f32> {\n  return vec4(toLinear3(v.rgb), v.a);\n}\n\n@export fn toGamma(v: f32) -> f32 {\n  return pow(v, 1.0 / gamma);\n}\n\n@export fn toGamma2(v: vec2<f32>) -> vec2<f32> {\n  return pow(v, vec2<f32>(1.0 / gamma));\n}\n\n@export fn toGamma3(v: vec3<f32>) -> vec3<f32> {\n  return pow(v, vec3<f32>(1.0 / gamma));\n}\n\n@export fn toGamma4(v: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(toGamma3(v.rgb), v.a);\n}\n",
  "use/light": "struct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n@export @group(LIGHT) @binding(LIGHT) var<uniform> lightUniforms: LightUniforms;\n",
  "@use-gpu/wgsl/use/light": "struct LightUniforms {\n  lightPosition: vec4<f32>;\n  lightColor: vec4<f32>;\n};\n\n@export @group(LIGHT) @binding(LIGHT) var<uniform> lightUniforms: LightUniforms;\n",
  "use/picking": "struct PickingUniforms {\n  pickingId: u32;\n};\n\n@group(PICKING) @binding(PICKING) var<uniform> pickingUniforms: PickingUniforms;\n\n@export fn getPickingColor(fragIndex: u32) -> vec4<u32> {\n  var r = pickingUniforms.pickingId;\n  var g = fragIndex;\n  return vec4<u32>(r, g, 0u, 0u);\n}\n",
  "@use-gpu/wgsl/use/picking": "struct PickingUniforms {\n  pickingId: u32;\n};\n\n@group(PICKING) @binding(PICKING) var<uniform> pickingUniforms: PickingUniforms;\n\n@export fn getPickingColor(fragIndex: u32) -> vec4<u32> {\n  var r = pickingUniforms.pickingId;\n  var g = fragIndex;\n  return vec4<u32>(r, g, 0u, 0u);\n}\n",
  "use/types": "@export struct SolidVertex {\n  position: vec4<f32>;\n  color: vec4<f32>;\n  uv: vec2<f32>;\n};\n\n@export struct MeshVertex {\n  position: vec4<f32>;\n  normal: vec3<f32>;\n  color: vec4<f32>;\n  uv: vec2<f32>;\n};\n",
  "@use-gpu/wgsl/use/types": "@export struct SolidVertex {\n  position: vec4<f32>;\n  color: vec4<f32>;\n  uv: vec2<f32>;\n};\n\n@export struct MeshVertex {\n  position: vec4<f32>;\n  normal: vec3<f32>;\n  color: vec4<f32>;\n  uv: vec2<f32>;\n};\n",
  "use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@export @group(VIEW) @binding(VIEW) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn clipToScreen3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewSize, position.z);\n}\n\n@export fn screenToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, position.z);\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  var pos = viewToClip(worldToView(position));\n  return pos.xyz / pos.w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  var m = viewUniforms.projectionMatrix;\n  var worldScale = m[1][1] * viewUniforms.viewWorldUnit;\n  var clipScale = mix(1.0, worldScale / w, f);\n  var pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n",
  "@use-gpu/wgsl/use/view": "struct ViewUniforms {\n  projectionMatrix: mat4x4<f32>;\n  viewMatrix: mat4x4<f32>;\n  viewPosition: vec4<f32>;\n  viewResolution: vec2<f32>;\n  viewSize: vec2<f32>;\n  viewWorldUnit: f32;\n  viewPixelRatio: f32;\n};\n\n@export @group(VIEW) @binding(VIEW) var<uniform> viewUniforms: ViewUniforms;\n\n@export fn worldToView(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.viewMatrix * position;\n}\n\n@export fn viewToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewUniforms.projectionMatrix * position;\n}\n\n@export fn worldToClip(position: vec4<f32>) -> vec4<f32> {\n  return viewToClip(worldToView(position));\n}\n\n@export fn clipToScreen3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewSize, position.z);\n}\n\n@export fn screenToClip3D(position: vec4<f32>) -> vec3<f32> {\n  return vec3(position.xy * viewUniforms.viewResolution, position.z);\n}\n\n@export fn worldToClip3D(position: vec4<f32>) -> vec3<f32> {\n  var pos = viewToClip(worldToView(position));\n  return pos.xyz / pos.w;\n}\n\n@export fn getPerspectiveScale(w: f32, f: f32) -> f32 {\n  var m = viewUniforms.projectionMatrix;\n  var worldScale = m[1][1] * viewUniforms.viewWorldUnit;\n  var clipScale = mix(1.0, worldScale / w, f);\n  var pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n"
};
export default WGSLModules;
